This file is to document design decisions that were integral to the writing of the simple-pic example in the evolutionary darma spec. 
I will first describe the basic structure of the MPI version of simple pic. I will then document how, and to what extent, it was
ported to the darma spec. The aim is to list the features/constraints in the spec, which will hopefully get better with each version
increment.

///////////////////////////////////////////////////////////////////////////////////////////
---------------------MPI version of simple-pic--------------------------------------------

The two main classes in the MPI version (and their breif description):
   1) Mesh - The class that holds the mesh data structure for each rank. The mesh is a bunch of 
             hexahedral MeshElements each of which has an index (local/global) and the corner 
             coordinates. Each Mesh object corresponds to one chunk in a 3D rectangulat Cartesian
             domain decomposition, so holds integers that represent this decomposition (rank, neighbour
             info etc.). 

   2) Particles - The class that holds the list of particles (std::vec) for this rank. It holds a 
              const reference to the Mesh object of this rank. It also has the main functions that
              perform the move/sort/migrate. Move refers to the element-wise moving of each particle
              until the time elapses, or they reach the boundary of hte local mesh. Sort refers to
              sorting the particles that need to be sent to each of the 6 neighbours into separate 
              lists. Migrate does the actual send/receive to/from each neighbour. 

There are a few auxiliary classes that support the above main classes:
   1) MeshElement - stuct for a simple hexahedral element.

   2) MeshOracle - A class that does something akin to MPI_cart_create/MPI_cart_rank functionality.

   3) Grid3D - Class to hold/compute/return the info for cartesian mesh topology.  

   4) Particle - Struct to hold the info for each particle such as its position, velocity, time_left
               (for the move in the current iteration) and state.


The main function simply initialises a Mesh and Particles object, sets up the MeshOracle based topology
and calls the Particles::move_all_distributed function for a specified delta_t. The move_all_distributed 
function is simply a wrapper around the move/sort/migrate functions, and calls them in a do-while loop
with the condition for the loop being as long as non-zero particles need to be migrated. The condition
is checked via a simple all-reduce where each rank contributes the number of particles it needs to send
across boundaries to neighbours. This is the de-facto quiescence detection mechanism.


/////////////////////////////////////////////////////////////////////////////////////////////////
---------------------DARMA 0.2.0 version of simple-pic--------------------------------------------

Because extensive object oriented programming poses challenges for the capture mechanism that darma
has to provide safely, there are a few restrictions/constraints for porting the simple-pic example
as is. The main restrictions are as follows (for details, David Hollman is the right person to contact):

1) In initialising an object of a class, it is not clear to me whether the constructor can be called, or
can be expected to be called, automatically. Since interfacing with data is done through access handles and
keys, it is not clear where is the safest point to call a constructor. Is it when an initial_access handle
is declared, or a publish on an initial_access handle is called? What is the mechanism by which arguments
(if any) can be passed to the constructor? As per Jeremy/David's suggestion, I've expressed the constructor
as just a simple member function of the class.

2) From a handle to class, you can get a reference to that object, and then can call member functions
with that reference. This is what I have done for initialising the Mesh and Particles objects. However,
member functions cannot call other member functions. So when porting them from the MPI version, I've 
merged/inlined them. It is not clear to me what the supported behaviour will be when different member functions
read/write different subsets of the data members? For now, I've two member functions in the Mesh class (one
to set up the mesh elements and another to set up the Cartesian topology). Is this safe? Likewise, I have
two member functions in the Particles class (one to initialize the particles, and another to do the move).  

3) Classes cannot hold const references to other classes (David can articulate this restriction better), 
because of stack/heap considerations??? So declare classes as mutually exclusive. In the MPI version the
Particles::Particles() constructor received a Mesh object argument, that it used to set the const ref to 
the mesh class it held. This was needed to initialize the particles positions within this mesh. Here, I've 
removed the const ref to the Mesh class from inside the Particles class. Instead the Particles::initializeParticles
function simply receives as const arguments the mesh related info.  

4) The biggest thing missins in 0.2, that will be supported in later versions, is collectives. Without a 
collective or an alternative quiescence detection mechanism, the particles migrate can not be done efficiently.
David suggested I implement a naive publish/fetch mechanism where every one contributes to a int array that 
lists the particles that need migrating from each rank, and everyone fetches it, sort of like a naive all-to-all.
I don't see much point in this. So, I've not implemented the distributed move. I've only implemented one task that 
moves the particles once from their initialized locations to the edge of the mesh on this rank. 
