%!TEX root = sandReportSpec.tex

\chapter{Backend}
\label{chap:back_end}

The \gls{back end} \gls{API} is organized into two namespaces:
\begin{compactenum}
\item {\ttfamily darma\_runtime::abstract::frontend} 
\item {\ttfamily darma\_runtime::abstract::backend}  
\end{compactenum}

The first contains
abstraction base classes of entities that are implemented in the \gls{translation
layer} and are the only constructs in that layer that the \gls{back end}
\gls{runtime system} is
allowed to interact with.  The second contains abstract base classes that must
be concretely implemented in the \gls{back end} \gls{runtime system} and
are the only \gls{back end} abstractions the \gls{translation layer} is allowed to interact
with.  Below is a summary of the requirements to implement these abstractions,
the documentation for which is taken from the Doxygen-style comments in
the source code itself.  As such, the source code may be a better resource for
those interested in this part of the document, but we have included it here for
completeness. 

\section{Important Backend Concepts}
Although some of this terminology was given in the introduction, we repeat definitions here.
Some of the terms here have \CC{} classes that directly represent them.
Other terms are only concepts, useful in illustrating the use of other \CC{} classes.
\begin{compactdesc}
\item [Task:] The work unit instantiated directly by the application developer. 
Tasks are guaranteed to make forward progress, but are interruptible.
\item [Execution stream:] An \gls{execution stream} will consist of a sequence of
  many \glspl{task}, and, like \glspl{task}, is guaranteed to make forward progress.
  All \glspl{execution stream} are \glspl{task}, but \glspl{execution stream} specifically
  have no parent \gls{task} and are the root of an independent \gls{task-DAG}.
  There is no class corresponding uniquely to an \gls{execution stream} since all
streams are \glspl{task}.
\item [Operation:] This is a unit of execution that is guaranteed to be non-interruptible. 
  An \gls{operation} is not equivalent to a \gls{task} since \glspl{task} are interruptible.  
  \Glspl{operation} are the smallest, schedulable units of work.  
A \gls{task} consists of a sequence of \glspl{operation}.
While \glspl{task} are explicitly instantiated by the application developer,
\glspl{operation}
(individual portions of \gls{task}) can be implicitly instantiated by the
\gls{runtime system}.
There is no class provided corresponding directly to an \gls{operation}.
Since only one component \gls{operation} of a \gls{task} may be active at any given
time, a \gls{task} always corresponds uniquely to an \gls{operation}.
\item [Handle:] The \gls{DARMA} generalization of a variable. Handle encapsulates both a unique immutable name (key) and an immutable type. 
\item [Logical Time:] An abstract notion of time progressing as
  \glspl{operation} are performed on the values encapsulated by a Handle.
There is no class corresponding to logical time. 
The progression of logical time for Use objects is encapsulated in the input and output Flows (see below).
\item [Use:] A Use corresponds to a Handle at a particular moment in logical time. 
  Uses are always unique to an \gls{operation}.
Operations cannot add or remove uses from its context.
Tasks, being interruptible, can add and remove Use instances.
Uses carry particular permissions and therefore have some intent of Read, Write, or Modify.
\item [Flow:] A Flow encapsulates a data-task relationship. 
An input Flow indicates that a Use requires a particular value before its
corresponding \gls{operation} begins.
An output Flow indicates that a Use produces a particular value after being
released at the end of its corresponding \gls{operation}.
All Use objects have exactly two Flow objects --- one input and one output ---
and each Flow is associated with exactly one Use.
A Modify Use will have an input Flow indicating the value consumed and an output Flow indicating the value produced.
A Read Use will also have an output Flow even though it produces no data since the ``output'' indicates the release of data and clearing of an anti-dependence.
\item [Dependency:] Although Dependency is not a class in \gls{DARMA}, a
  \gls{task} will always have an initial set of Uses that must become
  available for the \gls{task} to begin.
  This initial set of uses are the ``dependencies'' of a \gls{task}.
\end{compactdesc} 

\subimport{./doxygen-backend/latex/}{refman}
