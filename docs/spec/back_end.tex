%!TEX root = sandReportSpec.tex

\chapter{Back End API}
\label{chap:back_end}

The back end API is organized into two namespaces:
\inlinecode{dharma_runtime::abstract::frontend} and
\inlinecode{dharma_runtime::abstract::backend}.  The former contains
abstraction base classes of entities that are implemented in the translation
layer and are the only constructs in that layer that the backend is
allowed to interact with.  The latter contains abstract base classes and a
single function signature that must be concretely implemented in the backend and
are the only backend abstractions the translation layer is allowed to interact
with.  Below is a summary of the requirements to implement these abstractions,
the documentation for which is taken largely from the Doxygen-style comments in
the source code itself.  As such, the source code may be a better resource for
those interested in this part of the document, but we have included it here for
completeness.  Note that some template parameters have been omitted from this
documentation for succinctness.  For more information, see source code.

\section{Function signatures in \inlinecode{dharma_runtime::abstract::backend}}

\subsection{darma\_backend\_initialize()}
\begin{CppCode}
extern void
darma_backend_initialize(
  int& argc, char**& argv,
  runtime_t*& backend_runtime,
  types::unique_ptr_template<typename runtime_t::task_t> top_level_task
);
\end{CppCode}

\paragraph{Brief description:} Initialize the \inlinecode{backend::Runtime} instance.
 
\paragraph{Remarks:} This should be called once per top-level task.  The backend may chose whether
  the frontend is allowed to have multiple top-level tasks in one process.  If the backend
   supports multiple top-level tasks, it should define the preprocessor constant
   DARMA\_BACKEND\_TOP\_LEVEL\_TASK\_MULTIPLE.  If not, it should define the constant
   DARMA\_BACKEND\_TOP\_LEVEL\_TASK\_SINGLE.  The frontend is free to wrap these macro constants
   in more user-friendly names before exposing them to the user.
 
\paragraph{Pre conditions} The frontend should do nothing that interacts with the backend before this
   function is called.
 
\paragraph{Post conditions:} Upon return, the (output) parameter \inlinecode{backend_runtime} should point to  a valid
   instance of \inlinecode{backend::Runtime}.  All methods of \inlinecode{backend_runtime} should be invocable
   from any thread with access to the pointer \inlinecode{backend_runtime}.  The runtime should assume
   control of the (owning) pointer passed in through top\_level\_task and should not delete
   it before \inlinecode{Runtime::finalize()} is called on the \inlinecode{backend_runtime object}.  The top-level
   task object should be setup as described below.
 
\paragraph{Parameters:}
\begin{compactdesc} 
\item[argc] An lvalue reference to the argc passed into \inlinecode{main()}.
\item[argv] An lvalue reference to the argv passed into \inlinecode{main()}.
\item[backend\_runtime] The input value of this parameter is ignored.  On return, it should
   point to a properly initialized instance of \inlinecode{backend::Runtime}.  The backend owns this
   instance, and should delete it at some point after the frontend calls \inlinecode{Runtime::finalize()} on
   this instance.
\item[top\_level\_task] The task object to be returned by \inlinecode{Runtime::get_running_task()} if that
   method is invoked (on the instance pointed to by \inlinecode{backend_runtime} upon return) from the outermost
   task context within which \inlinecode{darma_backend_initialize()} was invoked.  (Inside of any task context
   created by an invocation of \inlinecode{Task::run()}, of course, the runtime should still behave as documented
   in the \inlinecode{Runtime::get_running_task()} method).  It is \emph{not} valid to call \inlinecode{Task::run()} on this
   top-level task object (i.e., it is an error), and doing so will cause the frontend to abort.
   Indeed (as of 0.2 spec), the only valid methods for the backend to call on this object are
   \inlinecode{Task::set_name()} and \inlinecode{Task::get_name()}.  At least before returning top\_level\_task from any calls to
   \inlinecode{Runtime::get_running_task()}, the backend runtime should assign a name to the top-level task
   with at least three parts, the first three of which must be: a string constant defined by the
   preprocessor macro DARMA\_BACKEND\_SPMD\_KEY\_PREFIX, a \inlinecode{std::size_t} for the rank of the SPMD-like
   top-level task from which initialize was invoked, and a \inlinecode{std::size_t} givin the total number of
   ranks in the SPMD launch (which must be known at launch time; SPMD ranks cannot be dynamically
   allocated).  In other words, the backend should make a call of the form:
   \inlinecode{top_level_task->set_name(DARMA_BACKEND_SPMD_NAME_PREFIX, rank, size);}
\end{compactdesc}

\paragraph{Remark:} The backend is free to extract backend-specific command-line arguments provided it
   updates \inlinecode{argc} and \inlinecode{argv}.  When \inlinecode{darma_backend_initialize()} returns, backend-specific parameters
   must no longer be in argc and argv.


\section{Abstract classes in \inlinecode{dharma_runtime::abstract::backend}}

\subsection{{Runtime}}
\inlinecode{Runtime} is an abstract class implemented by the backend containing
much of the runtime.  Thread safety of all methods in this class should be handled by the backend implementaton;
two threads must  be allowed to call any method in this class simultaneously, though undefined behavior
is allowed if nonsensical simultaneous calls are made (for instance, two calls registering the exact same
task at the same time).

The following summarizes the member functions of the runtime interface that
must be implemented, and details expected behavior and requirements for each
method.




\subsubsection{ Runtime::register\_task() }
\begin{CppCode}
virtual void register_task(
      task_unique_ptr&& task
    ) =0;
\end{CppCode}

\paragraph{Brief Description:} Enqueue a task that should run when its
dependencies are satisfied.
     
\paragraph{Pre conditions:} At the time of this call, it must be valid to call
\inlinecode{task->get_dependencies()}.  All \inlinecode{DependencyHandles}
       returned by \inlinecode{task->get_dependencies()} must be registered
       with this instance of \inlinecode{runtime} using either
       \inlinecode{register_handle()} or \inlinecode{register_fetching_handle()}
         and must not have been released yet using
           \inlinecode{release_handle()}.
       It must be valid to call \inlinecode{needs_read_data()} and
         \inlinecode{needs_write_data()} on \inlinecode{task} with any of the handles
       returned by \inlinecode{get_dependencies()}.  At least by the time that
         \inlinecode{DependencyHandle::is_satisfied()} returns
       true for all \inlinecode{DependencyHandles} returned by
         \inlinecode{task->get_dependencies()}, it must be valid to call
           \inlinecode{task->run()}.
     
\paragraph{Post conditions:} a task may be invoked at any subsequent time pending the satisfaction of the handles returned
       by \inlinecode{Task::get_dependencies()}
     
\paragraph{Parameters:} 
\begin{compactdesc}
\item[task] A unique pointer to the task to register and enqueue, meeting the preconditions
       described above.  The runtime backend now owns the task object and is responsible for deleting it
       after the task has finished running.  Any references or pointers to task are considered
       invalid after the task has run (i.e., Task::run() was invoked and returned), and thus should only
       be held by objects deleted inside Task::run() or objects deleted when task is deleted.
\end{compactdesc}
     

\subsubsection{Runtime::get\_running\_task()}
\begin{CppCode}
virtual task_t* const
    get_running_task() const =0;
\end{CppCode}

\paragraph{Brief Description:} Get a pointer to the \inlinecode{abstract::frontend::Task} object currently running on the thread 
from which \inlinecode{get_running_task()} was invoked.

\paragraph{Return value:} A non-owning pointer to the \inlinecode{abstract::frontend::Task} object running on the invoking
thread.  The returned pointer must be castable to the same concrete type as was passed to \inlinecode{Runtime::register_task()} when the task was registered.

\paragraph{Remarks:}
\begin{itemize}
\item If the runtime implements context switching, it must ensure that
     the behavior of \inlinecode{Runtime::get_running_task()} is consistent and correct for a given
     running thread as though the switching never occurred.
\item The pointer returned here is guaranteed to be valid until \inlinecode{Task::run()} returns for
     the returned task.  However, to allow context switching, it is not guaranteed to be valid
     in the context of any other task's \inlinecode{run()} invocation, including child tasks, and thus it should
     not be dereferenced in any other context.
\end{itemize}

\subsubsection{Runtime::register\_handle()}
\begin{CppCode}
virtual void register_handle(
      const handle_t* const handle
    ) =0;
\end{CppCode}

\paragraph{Brief description:} Register a local handle to a data block
       that can be used as a part of the return value of \inlinecode{Task::get_dependencies()} for tasks
       registered on this runtime instance.  Note that the *only* allowed return values of \inlinecode{get_dependencies()}
       for a task passed to \inlinecode{register_task()} on this instance are values for which \inlinecode{register_handle()} (or
       \inlinecode{register_fetching_handle()}) has been called and \inlinecode{release_handle()} has not yet been called.  If the
       dependency requires readable data to be marked as satisfied (i.e., if \inlinecode{t.needs_read_data(handle)}
       returns true when handle is returned as part of \inlinecode{Task::get_dependencies()} for a registered task \inlinecode{t}),
       the readable data requirement must be satisfied by the release of all previous versions of handle
       \emph{and} a call to \inlinecode{handle_done_with_version_depth()} on a handle with a penultimate subversion that is
       exactly 1 increment prior to the final subversion of \inlinecode{handle} and is at the same depth.  See
       \inlinecode{Runtime::handle_done_with_version_depth()} for more details.
     
     
     %  @sa Task::needs_read_data()
     %  @sa Runtime::register_task()
     %  @sa Runtime::register_fetcher()
     
\paragraph{Parameters:} 
\begin{compactdesc}
\item[handle] A (non-owning) pointer to a \inlinecode{abstract::frontend::DependencyHandle} for which it is
       valid to call \inlinecode{DependencyHandle::get_key()} and \inlinecode{DependencyHandle::get_version()} and for
       which \inlinecode{DependencyHandle::satisfy_with_data_block()} has not yet been called by the backend.  (The only
       way to ensure the latter of these conditions is to ensure it is not in the return value of
       \inlinecode{Task::get_dependencies()} for any task that \inlinecode{Runtime::register_task()} has been invoked with). The pointer
       passed to this parameter must be valid from the time \inlinecode{register_handle()} is called until the time
       \inlinecode{release_handle()} is called (on this instance!) with a handle to the same key and version.  This method
       may be called more than once globally with the same key and the same version, but it is a debug-mode
       error to register more than one task ({\bf globally}) that returns true for \inlinecode{Task::needs_write_data()} on
       that handle.  (Undefined behavior is still allowed in optimized mode)
\end{compactdesc}
    

\subsubsection{Runtime::register\_fetching\_handle()}
\begin{CppCode}
    virtual void
    register_fetching_handle(
      handle_t* const handle,
      const Key& user_version_tag,
      bool write_access_allowed
    ) =0;
\end{CppCode}

\paragraph{Brief description:} Register a dependency handle that is satisfied by retrieving data from the data store.
       The handle may then be used preliminarily as a dependency to tasks, etc.  Subsequents to the handle
       may be created with handle versions in similarly pending states.  Upon resolution of the \inlinecode{user_version_tag}
       to an internal Version (i.e., triggered by a publish of a handle with a matching key and matching user
       version tag), the handle and all registered subsequents should have their versions updated (i.e., using
       \inlinecode{Version::operator+()} and \inlinecode{DependencyHandle::set_version()}) to incorporate the fetched base version.
     
\paragraph{Parameters:}
\begin{compactdesc} 
\item[handle] A (non-owning) pointer to a \inlinecode{DependencyHandle} for which it must be valid to call \inlinecode{get_key()}
     but for which the return value of \inlinecode{get_version()} is ignored.
     
\item[user\_version\_tag] A Key to be used to match a publication version of the same key reported
       by \inlinecode{handle->get_key()} published elsewhere.
     
\item[write\_access\_allowed] A boolean indicating that the handle is allowed to occupy a write role in
       a task; i.e., \inlinecode{t.needs_write_data(handle)} can return true for up to one Task \inlinecode{t} registered with this instance.
       It is the responsibility of the frontend to ensure (either through semantics or user responsibility) that
       \inlinecode{register_handle()} is not called with a handle to the same key and the same version tag and
       \inlinecode{write_access_allowed=true} more than once {\bf globally}.  To do so is a debug mode error/optimized mode
       undefined behavior.  Also, if a \inlinecode{frontend::Task} instance returns true for \inlinecode{Task::needs_write_data()}
       on a handle that was registered with \inlinecode{write_access_allowed=false}, a debug mode error should be raised
       (undefined behavior is allowed in optimized mode).
\end{compactdesc}
     
\paragraph{Remarks:} For the 0.2.0 spec implementation, \inlinecode{write_access_allowed} should always be false


\subsubsection{Runtime::release\_read\_only\_usage()}
\begin{CppCode}
    virtual void
    release_read_only_usage(
      const handle_t* const handle
    ) =0;
\end{CppCode}

\paragraph{Brief description:} Release the ability to create tasks that depend on handle as read-only.  The handle can
     then only be used up to once more in a (read-)write context before it is released.
     All handles can be used in a write context (i.e., be part of the return for \inlinecode{Task::get_dependencies()}
       for a task that returns true for \inlinecode{needs_write_data()} on that handle) at *most* once in their lifetime
       (from \inlinecode{register_handle()}/\inlinecode{register_fetching_handle()} to \inlinecode{release_handle()}).  This (up to) one "final"
       usage must run after all read-only uses of the handle; however not all read-only uses of
       a handle need to be registered by time the task making the "final" usage is registered.  Thus,
       the frontend needs to indicate when no more read-only usages will be created, thus allowing
       the "final" usage to clear its antidependencies.
       This method indicates that no more tasks will be registered that use handle in a read context
       but not in a write context (a maximum of one task may use handle in a write context anyway).
       The frontend may choose to call this after all tasks making read uses have *finished*, but this
       is not a requirement currently.  It must be called for all handles before \inlinecode{release_handle()} is
       called.  It is an error to call \inlinecode{release_handle()} on a handle before calling \inlinecode{release_read_only_usage()}.
     
\paragraph{Parameters:}
\begin{compactdesc} 
\item[handle] a non-owning pointer to a \inlinecode{DependencyHandle} for which \inlinecode{register_handle()} or
     \inlinecode{register_fetching_handle()} has been called on this instance but for which \inlinecode{release_handle()} has not
       yet been called.
\end{compactdesc}


\subsubsection{Runtime::release\_handle()}
\begin{CppCode}
    virtual void
    release_handle(
      const handle_t* const handle
    ) =0;
\end{CppCode}

\paragraph{Brief description:} Release a previously registered handle, indicating that no more tasks will be registered
       with \inlinecode{handle} as an output (at least using the instance registered with \inlinecode{register_handle()}).
     
\paragraph{Parameters:} 
\begin{compactdesc}
\item[handle] A (non-owning) pointer to the same object with which \inlinecode{Runtime::register_handle()} (or
       \inlinecode{register_fetching_handle()}) was previously invoked.  Any (frontend or backend) uses of \inlinecode{handle}
       after \inlinecode{release_handle()} is returns are invalid and result in undefined behavior.  Upon release,
       if the handle has been published with \inlinecode{Runtime::publish_handle()} or if the handle was registered
       as the last subversion at a given depth using \inlinecode{Runtime::handle_done_with_version_depth()}, the
       appropriate action(s) should be taken to satisfy dependencies requiring data from the data block
       in \inlinecode{handle} (i.e., the return value of \inlinecode{handle->get_data_block()}).  If neither of these uses have
       been performed at the time of release, it is safe for the runtime to garbage collect the data block
       returned by \inlinecode{handle->get_data_block()}.
\end{compactdesc}


\subsubsection{Runtime::handle\_done\_with\_version\_depth()}
\begin{CppCode}
    virtual void
    handle_done_with_version_depth(
      const handle_t* const handle
    ) =0;
\end{CppCode}

\paragraph{Brief description:} Indicate that no further subversions at the current version depth will be created.
     Essentially, this establishes a satisfy-upon-release relationship between \inlinecode{handle} and a handle
      with the subsequent of the penultimate subversion of handle.  In other words, if \inlinecode{handle} has
       version a.b.c.d (for some values a, b, c, and d of incrementable type, e.g., integers), then this
      indicates to the runtime that a call to \inlinecode{Runtime::release_handle()} on \inlinecode{handle} should lead to a
       call of (for some handle \inlinecode{h2} with the same key and version a.b.(++c)):
          \inlinecode{h2->satisfy_with_data_block(handle->get_data_block());}
       where \inlinecode{h2} must be registered at the time of that \inlinecode{Runtime::handle_done_with_version_depth()} is invoked
       on \inlinecode{handle}.  If no such handle is registered and no publications of handle have been made at the time
       of this invocation, the runtime is free to garbage collect the data block upon release.  Registering a
       handle with a version subsequent to the penultimate version of \inlinecode{handle} between this invocation and
       the release of handle will lead to undefined behavior.


\subsubsection{Runtime::publish\_handle()}
\begin{CppCode}
    virtual void
    publish_handle(
      const handle_t* const handle,
      const Key& version_tag,
      const size_t n_fetchers = 1,
      bool is_final = false
    ) =0;
\end{CppCode}

\paragraph{Brief description:} Indicate to the backend that the key and version reported by \inlinecode{handle} should be fetchable
       with the user version tag \inlinecode{vertion_tag} exactly \inlinecode{n_additional_fetchers} times.
       In other words, \inlinecode{Runtime::register_fetching_handle()} must be called exactly \inlinecode{n_fetchers} times
       {\bf globally} with the key reported by \inlinecode{handle} and the \inlinecode{version_tag} given here before the runtime
       can overwrite or delete the data associated with the key and version reported by \inlinecode{handle}.

\paragraph{Parameters:} 
\begin{compactdesc}
\item[handle] A (non-owning) pointer to a \inlinecode{DependencyHandle} registered with \inlinecode{register_handle()} but
       not yet released with \inlinecode{release_handle()}.  The handle must have been registered with \inlinecode{write_access_allowed=true}.
\item[version\_tag] A user-space tag to be associated with the internal version reported by handle
       and to be fetched as such
\item[n\_fetchers] The number of times \inlinecode{register_fetcher()} must be called globally (and the corresponding
      fetching handles released) before antidependencies on \inlinecode{handle} are cleared.
\item[is\_final] Whether or not the publish is intented to indicate the key and data associated with
       handle are to be considered globally read-only for the rest of its lifetime.  If true, it is a (debug-mode)
       error to register a handle (anywhere) with the same key and a version \inlinecode{v > handle->get_version()}
\end{compactdesc}


\subsubsection{Runtime::satisfy\_handle()}
\begin{CppCode}
    virtual void
    satisfy_handle(
      handle_t* const to_fill,
      bool needs_write_access = false
    ) =0;
\end{CppCode}


\subsubsection{Runtime::establish\_containment\_relationship()}
\begin{CppCode}
    virtual void
    establish_containment_relationship(
      const handle_t* const inner_handle,
      const handle_t* const outer_handle,
      containment_manager_t const& manager
    ) =0;
\end{CppCode}

\subsubsection{Runtime::establish\_aliasing\_relationship()}
\begin{CppCode}
    virtual void
    establish_aliasing_relationship(
      const handle_t* const handle_a,
      const handle_t* const handle_b,
      aliasing_manager_t const& manager
    ) =0;
\end{CppCode}

\subsubsection{Runtime::finalize()}
\begin{CppCode}
    virtual void
    finalize() =0;
\end{CppCode}

\paragraph{Brief description:} Signifies the end of the outer SPMD task from which \inlinecode{darma_backend_initialize()} was called.
     



\subsection{{DataBlock}}

The \inlinecode{DataBlock} class is the abstraction through which the frontend interacts with data stored and managed by the backend. The 
member functions of this class, and the details of thier implementation is as follows:

\subsubsection{DataBlock::get\_data()}
\begin{CppCode}
    virtual void*
    get_data() =0;
\end{CppCode}

\paragraph{Brief description:} Gets a (non-owning) pointer to deserialized version of the data associated with
      the data block.


% DSH removed for now, consistent with other features > 0.2.0.
%\subsubsection{DataBlock::acquire\_data()}
%\begin{CppCode}
%    virtual void
%    acquire_data(void* const data) =0;
%\end{CppCode}
%
%\paragraph{Remark:} This should never be invoked in the 0.2.0 spec implementation
%\todo[inline]{Should we just remove this function??}


%\subsection{{types}}

\section{Abstract Classes in \inlinecode{dharma_runtime::abstract::frontend}}
%\todo[inline]{need better section title}
%\todo[inline]{Add detail about how this is the interface that the back end has
%into the front end and translation layer}
%\todo[inline]{Add subsection for each class}

\subsection{{DependencyHandle}}
The class \inlinecode{DependencyHandle} provides the fundamental abstraction for the frontend to communicate units of
data dependence to the backend. The following are the functions of this class:

\subsubsection{DependencyHandle::get\_key()}
\begin{CppCode}
    virtual const Key&
    get_key() const =0;
\end{CppCode}

\paragraph{Brief description:} The key associated with the dependency.
       Other dependencies that share a key with this dependency denote a requirement of the same
       data block (though differing versions indicate that the requirement refers to a different
       snapshot in time of that data block).
     
\paragraph{Remark} The frontend must ensure that the return value for \inlinecode{get_key()} is the same from the
      time that \inlinecode{Runtime::register_handle()} or \inlinecode{register_fetching_handle()} is called with a given
       handle until \inlinecode{Runtime::release_handle()} is called with that same handle.


\subsubsection{DependencyHandle::get\_version()}
\begin{CppCode}
    virtual const Version&
    get_version() const =0;
\end{CppCode}

\paragraph{Brief description:} The version associated with the dependency.
       Versions are strictly ordered, hashable, incrementable objects for which the default constructed
       value is always less than or equal to all values.  See Version concept for more information
     
    
\subsubsection{DependencyHandle::set\_version()}
\begin{CppCode}
    virtual void
    set_version(const Version& v) =0;
\end{CppCode}

\paragraph{Brief description:} Set the version associated with the dependency
       The backend may call \inlinecode{set_version()} on a given \inlinecode{DependencyHandle} at most one time between
       the handle's registration and release, and only if \inlinecode{set_version_is_pending(true)} has been
       called (which should only be done if this handle or another with an earlier version from
       which this handle was derived was registered with \inlinecode{Runtime::register_fetching_handle()}
       and the handle's actual version is pending the resolution of the user version tag associated
       with that call).
     

\subsubsection{DependencyHandle::version\_is\_pending()}
\begin{CppCode}
    virtual bool
    version_is_pending() const =0;
\end{CppCode}

\paragraph{Brief description:} Returns true if the backend has called \inlinecode{set_version_is_pending(true)} on the handle
       and if \inlinecode{set_version_is_pending(false)} and/or \inlinecode{set_version()} has not been called since.
     

\subsubsection{DependencyHandle::get\_serialization\_manager()}
\begin{CppCode}
    virtual SerializationManager*
    get_serialization_manager() =0;
\end{CppCode}

\paragraph{Brief description:} Return the serialization manager describing how to allocate, pack, and unpack the data
       associated with the dependency
     
\paragraph{Remark} In the 0.2.0 spec implementation, the only relevant piece of information the \inlinecode{SerializationManager}
       returns is the size of the metadata (i.e., the stack size; literally \inlinecode{sizeof(T)} for some type T) so that
       the backend can allocate data for data blocks.
     
\subsubsection{DependencyHandle::satisfy\_with\_data\_block()}
\begin{CppCode}
    virtual void
    satisfy_with_data_block(
      abstract::backend::DataBlock* const data
    ) =0;
\end{CppCode}

\paragraph{Brief description} Satisfy the dependency handle with data or with an allocated buffer into which data
       may be written.
       The underlying data in the data block may not be written to until the backend calls
       \inlinecode{DependencyHandle::allow_writes()} on this handle.  This method should be called at most
       once in the lifetime of a \inlinecode{DependencyHandle}, and it should only be called zero times if
       no tasks were registered during its lifetime that reported a dependence on the handle.
     
\paragraph{Parameters:} 
\begin{compactdesc}
\item[data] A (non-owning) pointer to the data block for the \inlinecode{DependencyHandle} to use for
       all data operations.  If any tasks have been used in any read contexts before
       \inlinecode{Runtime::release_read_only_usage()} was called with the handle, or if the up to one
       "final" usage (see \inlinecode{Runtime::release_read_only_usage()} for details) of the handle is a task
       that returns true for \inlinecode{Task::needs_read_data(handle)}, the readable data must be available
       at the time of this invocation.  Otherwise, a buffer of the correct size to contain
       the metadata as described by the serialization manager should be allocated.  As of
       the 0.2 spec, the handle and data block should not be moved from the time
       \inlinecode{satisfy_with_data_block()} is called until the time \inlinecode{Runtime::release_handle()} is called
       (i.e., the pointer passed in here should be valid until \inlinecode{Runtime::release_handle()} is called).
\end{compactdesc}

\subsubsection{DependencyHandle::get\_data\_block()}
\begin{CppCode}
    virtual abstract::backend::DataBlock*
    get_data_block() =0;
\end{CppCode}

\paragraph{Brief description} Get the pointer to the data block passed into \inlinecode{satisfy_with_data_block()} by the backend
       It is an (debug-mode) error to call this method before calling \inlinecode{satisfy_with_data_block()}


\subsubsection{DependencyHandle::is\_satisfied()}
\begin{CppCode}
    virtual bool
    is_satisfied() const =0;
\end{CppCode}

\paragraph{Brief description} Returns true if and only if \inlinecode{satisfy_with_data_block()} has been called for this instance.


\subsubsection{DependencyHandle::allow\_writes()}
\begin{CppCode}
    virtual void
    allow_writes() =0;
\end{CppCode}

\paragraph{Brief description} Notify the dependency handle that the last read-only usage of the handle has cleared
       and any additional usage until \inlinecode{Runtime::release_handle()} is called may safely modify the
       data in the associated data block.
       It is a (debug-mode) error to call \inlinecode{allow_writes()} before calling \inlinecode{satisfy_with_data_block()}.
       \inlinecode{allow_writes()} should be called at most once in the lifetime of a dependency handle, and
       it should only be called zero times if the handle is never used in a write context.


\subsubsection{DependencyHandle::is\_writable()}
\begin{CppCode}
    virtual bool
    is_writable() const =0;
\end{CppCode}

\paragraph{Brief description} Returns true if and only if \inlinecode{allow_writes()} has been called for this instance
     

\subsection{{Task}}
The class \inlinecode{Task} is the fundamental abstraction for the frontend to communicate units of
  dependency-driven work to the backend.


\subsubsection{Task::get\_dependencies()}
\begin{CppCode}
    virtual
    const Container<handle_t*>&
    get_dependencies() const =0;
\end{CppCode}

\paragraph{Brief description} Returns the dependencies and antidependencies of the task.
       All dependencies will return true when given as the argument of \inlinecode{Task::needs_read_data()}
       on this instance and all antidependencies will return true when given as the argument of
       \inlinecode{Task::needs_write_data()} (though write dependencies that do not overwrite data --- that is,
       initial versions --- will have version 0 and will not be true antidependencies).
     
\paragraph{Return value:} An iterable container of (non-owning) pointers to \inlinecode{DependencyHandle} objects.  The
       frontend must ensure that only pointers to handles registered with \inlinecode{Runtime::register_hanlde()}
       but not yet released with \inlinecode{Runtime::release_handle()} are returned by this method, and the
       pointers in the returned container must be remain valid until \inlinecode{Runtime::release_handle()}
       is called.  Furthermore, it is a debug-mode error for the frontend to return a handle that
       returns the same values for \inlinecode{get_key()} and \inlinecode{get_version()} but points to a different location
       in memory than the corresponding pointer registered with \inlinecode{Runtime::register_handle()}.


\subsubsection{Task::needs\_read\_data()}
\begin{CppCode}
    virtual bool
    needs_read_data(
      const handle_t* handle
    ) const =0;
\end{CppCode}

\paragraph{Brief description:} Returns true if and only if the task needs to read data from handle
     
\paragraph{Parameters:} 
\begin{compactdesc}
\item[handle] A (non-owning) pointer to the handle to be queried
\end{compactdesc}

\paragraph{Remarks} 
\begin{itemize}
\item The frontend must ensure that a Task {\bf must} return true for at least one of
       \inlinecode{needs_read_data()} or \inlinecode{needs_write_data()} for each handle in the container returned by
       \inlinecode{get_dependencies()}.  Failure to do so is a debug-mode error.
\item The return value of this method is unrelated to whether a dependency is
       satisfied or not.  Even for a handle that returns true for \inlinecode{handle->is_satisfied()},
       this method should return true iff the task needs to read the data from the handle.
\end{itemize}     


\subsubsection{Task::get\_name()}
\begin{CppCode}
    virtual const Key&
    get_name() const =0;
\end{CppCode}

\paragraph{Brief description} Returns the name of the task if one has been assigned with \inlinecode{set_name()}, or
       a reference to a default-constructed Key if not.
       In the 0.2 spec this is only used with the outermost task, which is named with
       a key of two \inlinecode{size_t} values: the SPMD rank and the SPMD size.  See \inlinecode{darma_backend_initialize()}
       for more information


\subsubsection{Task::set\_name()}
\begin{CppCode}
    virtual void
    set_name(const Key& name_key) =0;
\end{CppCode}

\paragraph{Brief description:} Returns the name of the task if one has been assigned with \inlinecode{set_name()}, or
       a reference to a default-constructed Key if not.
       In the 0.2 spec this is only used with the outermost task, which is named with
       a key of two \inlinecode{size_t} values: the SPMD rank and the SPMD size.  See \inlinecode{darma_backend_initialize()}
       for more information.


\subsubsection{Task::is\_migratable()}
\begin{CppCode}
    virtual bool
    is_migratable() const =0;
\end{CppCode}

\paragraph{Brief description} Returns true if and only if the task can be migrated.
     
\paragraph{Remark} Always return false in the 0.2 spec implementation.  Later specs will need
       additional hooks for migration



\subsubsection{Task::run()}
\begin{CppCode}
    virtual void
    run() const =0;
\end{CppCode}

\paragraph{Brief description} Run the task.
       This should be invoked only once all dependencies returned by \inlinecode{get_dependencies()}
       are in a satisfied state (i.e., they return true for \inlinecode{DependencyHandle::is_satisfied()}).
     
\paragraph{Post conditions} Upon return, it is no longer valid to call \inlinecode{get_dependencies()}, \inlinecode{needs_read_data()},
       or \inlinecode{needs_write_data()}.  In fact, the task is free to release these pointers (using
       \inlinecode{Runtime::release_handle()}) before \inlinecode{Task::run()} returns.
     
\paragraph{Remark} \inlinecode{Task::run()} need not be invoked on the same thread as it was created, nor on the
       same thread as the runtime querying its above methods.  However, while \inlinecode{run()} is executing
       on a given thread, any calls to \inlinecode{Runtime::get_running_task()} must return a pointer to
       this task object.  (If the runtime implements context switching, it must ensure that
       the behavior of \inlinecode{Runtime::get_running_task()} is consistent and correct for a given
       running thread as though the switching never occurred)


\subsection{{SerializationManager}}
The class \inlinecode{SerializationManager} is an immutable object allowing the backend to query various serialization sizes, offsets,
   behaviours, and data, known by the for a given handle and its associated data block.


\subsubsection{SerializationManager::get\_metadata\_size()}
\begin{CppCode}
    virtual size_t
    get_metadata_size(
      const void* const deserialized_data
    ) const =0;
\end{CppCode}

\paragraph{Brief description} Returns the size of the data as a (i.e., stack-allocated) C++ object in memory
     
\paragraph{Parameters:}
\begin{compactdesc} 
\item[deserialized\_data] In the 0.2.0 spec implementation, this should always be a null pointer
\end{compactdesc}

\paragraph{Remarks} Later revisions of the spec will allow classes to specify custom metadata serializers
       (e.g., in case there is substantial temporary metadata that doesn't need go over the wire or
       if some values need to change in preparation for migration).

