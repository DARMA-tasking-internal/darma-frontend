\chapter{Back End API}
\label{chap:back_end}

\todo[inline]{Add description about directory structure: front end (interface
    for backend developers into front end/translation layer. vs back end: what
    the  developer must implement.   }


\section{Backend Classes}
\todo[inline]{need better section title}
\todo[inline]{Add detail about how each of these must be implemented to support implementation}
\subsection{{runtime}}
\inlinecode{runtime} is an abstract class implemented by the backend containing
much of the runtime.  Thread safety of all methods in this class should be handled by the backend implementaton;
two threads must  be allowed to call any method in this class simultaneously, though undefined behavior
is allowed if nonsensical simultaneous calls are made (for instance, two calls registering the exact same
task at the same time).

The following summarizes the member functions of the runtime interface that
must be implemented, and details expected behavior and requirements for each
function.

\subsubsection{darma\_backend\_initialize()}
\begin{CppCode}
extern void
darma_backend_initialize(
  int& argc, char**& argv,
  runtime_t*& backend_runtime,
  types::unique_ptr_template<typename runtime_t::task_t> top_level_task
);
\end{CppCode}

\paragraph{Brief description:} Initialize the \inlinecode{backend::Runtime} instance.
 
\paragraph{Remarks:} This should be called once per top-level task.  The backend may chose whether
  the frontend is allowed to have multiple top-level tasks in one process.  If the backend
   supports multiple top-level tasks, it should define the preprocessor constant
   DARMA\_BACKEND\_TOP\_LEVEL\_TASK\_MULTIPLE.  If not, it should define the constant
   DARMA\_BACKEND\_TOP\_LEVEL\_TASK\_SINGLE.  The frontend is free to wrap these macro constants
   in more user-friendly names before exposing them to the user.
 
\paragraph{Pre conditions} The frontend should do nothing that interacts with the backend before this
   function is called.
 
\paragraph{Post conditions:} Upon return, the (output) parameter \inlinecode{backend_runtime} should point to  a valid
   instance of \inlinecode{backend::Runtime}.  All methods of \inlinecode{backend_runtime} should be invocable
   from any thread with access to the pointer \inlinecode{backend_runtime}.  The runtime should assume
   control of the (owning) pointer passed in through top\_level\_task and should not delete
   it before \inlinecode{Runtime::finalize()} is called on the \inlinecode{backend_runtime object}.  The top-level
   task object should be setup as described below.
 
\paragraph{Parameters:}
\begin{compactdesc} 
\item[argc] An lvalue reference to the argc passed into \inlinecode{main()}.
\item[argv] An lvalue reference to the argv passed into \inlinecode{main()}.
\item[backend\_runtime] The input value of this parameter is ignored.  On return, it should
   point to a properly initialized instance of \inlinecode{backend::Runtime}.  The backend owns this
   instance, and should delete it at some point after the frontend calls \inlinecode{Runtime::finalize()} on
   this instance.
\item[top\_level\_task] The task object to be returned by \inlinecode{Runtime::get_running_task()} if that
   method is invoked (on the instance pointed to by \inlinecode{backend_runtime} upon return) from the outermost
   task context within which \inlinecode{darma_backend_initialize()} was invoked.  (Inside of any task context
   created by an invocation of \inlinecode{Task::run()}, of course, the runtime should still behave as documented
   in the \inlinecode{Runtime::get_running_task()} method).  It is \emph{not} valid to call \inlinecode{Task::run()} on this
   top-level task object (i.e., it is an error), and doing so will cause the frontend to abort.
   Indeed (as of 0.2 spec), the only valid methods for the backend to call on this object are
   \inlinecode{Task::set_name()} and \inlinecode{Task::get_name()}.  At least before returning top\_level\_task from any calls to
   \inlinecode{Runtime::get_running_task()}, the backend runtime should assign a name to the top-level task
   with at least three parts, the first three of which must be: a string constant defined by the
   preprocessor macro DARMA\_BACKEND\_SPMD\_KEY\_PREFIX, a \inlinecode{std::size_t} for the rank of the SPMD-like
   top-level task from which initialize was invoked, and a \inlinecode{std::size_t} givin the total number of
   ranks in the SPMD launch (which must be known at launch time; SPMD ranks cannot be dynamically
   allocated).  In other words, the backend should make a call of the form:
   \inlinecode{top_level_task->set_name(DARMA_BACKEND_SPMD_NAME_PREFIX, rank, size);}
\end{compactdesc}

\paragraph{Remark:} The backend is free to extract backend-specific command-line arguments provided it
   updates \inlinecode{argc} and \inlinecode{argv}.  When \inlinecode{darma_backend_initialize()} returns, backend-specific parameters
   must no longer be in argc and argv.




\subsubsection{ register\_task() }
\begin{CppCode}
virtual void register_task(
      task_unique_ptr&& task
    ) =0;
\end{CppCode}

\paragraph{Brief Description:} Enqueue a task that should run when its
dependencies are satisfied.
     
\paragraph{Pre conditions:} At the time of this call, it must be valid to call
\inlinecode{task->get_dependencies()}.  All \inlinecode{DependencyHandles}
       returned by \inlinecode{task->get_dependencies()} must be registered
       with this instance of \inlinecode{runtime} using either
       \inlinecode{register_handle()} or \inlinecode{register_fetching_handle()}
         and must not have been released yet using
           \inlinecode{release_handle()}.
       It must be valid to call \inlinecode{needs_read_data()} and
         \inlinecode{needs_write_data()} on \inlinecode{task} with any of the handles
       returned by \inlinecode{get_dependencies()}.  At least by the time that
         \inlinecode{DependencyHandle::is_satisfied()} returns
       true for all \inlinecode{DependencyHandles} returned by
         \inlinecode{task->get_dependencies()}, it must be valid to call
           \inlinecode{task->run()}.
     
\paragraph{Post conditions:} a task may be invoked at any subsequent time pending the satisfaction of the handles returned
       by \inlinecode{Task::get_dependencies()}
     
\paragraph{Parameters:} 
\begin{compactdesc}
\item[task] A unique pointer to the task to register and enqueue, meeting the preconditions
       described above.  The runtime backend now owns the task object and is responsible for deleting it
       after the task has finished running.  Any references or pointers to \ref task are considered
       invalid after the task has run (i.e., \ref Task::run() was invoked and returned), and thus should only
       be held by objects deleted inside Task::run() or objects deleted when \ref task is deleted.
\end{compactdesc}
     

\subsubsection{get\_running\_task()}
\begin{CppCode}
virtual task_t* const
    get_running_task() const =0;
\end{CppCode}

\paragraph{Brief Description:} Get a pointer to the \inlinecode{abstract::frontend::Task} object currently running on the thread 
from which \inlinecode{get_running_task()} was invoked.

\paragraph{Return value:} A non-owning pointer to the \inlinecode{abstract::frontend::Task} object running on the invoking
thread.  The returned pointer must be castable to the same concrete type as was passed to \inlinecode{Runtime::register_task()} when the task was registered.

\paragraph{Remarks:}
\begin{itemize}
\item If the runtime implements context switching, it must ensure that
     the behavior of \inlinecode{Runtime::get_running_task()} is consistent and correct for a given
     running thread as though the switching never occurred.
\item The pointer returned here is guaranteed to be valid until \inlinecode{Task::run()} returns for
     the returned task.  However, to allow context switching, it is not guaranteed to be valid
     in the context of any other task's \inlinecode{run()} invocation, including child tasks, and thus it should
     not be dereferenced in any other context.
\end{itemize}

\subsubsection{register\_handle()}
\begin{CppCode}
virtual void register_handle(
      const handle_t* const handle
    ) =0;
\end{CppCode}

\paragraph{Brief description:} Register a local handle to a data block
       that can be used as a part of the return value of \inlinecode{Task::get_dependencies()} for tasks
       registered on this runtime instance.  Note that the *only* allowed return values of \inlinecode{get_dependencies()}
       for a task passed to \inlinecode{register_task()} on this instance are values for which \inlinecode{register_handle()} (or
       \inlinecode{register_fetching_handle()}) has been called and \inlinecode{release_handle()} has not yet been called.  If the
       dependency requires readable data to be marked as satisfied (i.e., if \inlinecode{t.needs_read_data(handle)}
       returns true when handle is returned as part of \inlinecode{Task::get_dependencies()} for a registered task \inlinecode{t}),
       the readable data requirement must be satisfied by the release of all previous versions of handle
       \emph{and} a call to \inlinecode{handle_done_with_version_depth()} on a handle with a penultimate subversion that is
       exactly 1 increment prior to the final subversion of \inlinecode{handle} and is at the same depth.  See
       \inlinecode{Runtime::handle_done_with_version_depth()} for more details.
     
     
     %  @sa Task::needs_read_data()
     %  @sa Runtime::register_task()
     %  @sa Runtime::register_fetcher()
     
\paragraph{Parameters:} 
\begin{compactdesc}
\item[handle] A (non-owning) pointer to a \inlinecode{abstract::frontend::DependencyHandle} for which it is
       valid to call \inlinecode{DependencyHandle::get_key()} and \inlinecode{DependencyHandle::get_version()} and for
       which \inlinecode{DependencyHandle::satisfy_with_data_block()} has not yet been called by the backend.  (The only
       way to ensure the latter of these conditions is to ensure it is not in the return value of
       \inlinecode{Task::get_dependencies()} for any task that \inlinecode{Runtime::register_task()} has been invoked with). The pointer
       passed to this parameter must be valid from the time \inlinecode{register_handle()} is called until the time
       \inlinecode{release_handle()} is called (on this instance!) with a handle to the same key and version.  This method
       may be called more than once globally with the same key and the same version, but it is a debug-mode
       error to register more than one task ({\bf globally}) that returns true for \inlinecode{Task::needs_write_data()} on
       that handle.  (Undefined behavior is still allowed in optimized mode)
\end{compactdesc}
    

\subsubsection{register\_fetching\_handle()}
\begin{CppCode}
    virtual void
    register_fetching_handle(
      handle_t* const handle,
      const Key& user_version_tag,
      bool write_access_allowed
    ) =0;
\end{CppCode}

\paragraph{Brief description:} Register a dependency handle that is satisfied by retrieving data from the data store.
       The handle may then be used preliminarily as a dependency to tasks, etc.  Subsequents to the handle
       may be created with handle versions in similarly pending states.  Upon resolution of the \inlinecode{user_version_tag}
       to an internal Version (i.e., triggered by a publish of a handle with a matching key and matching user
       version tag), the handle and all registered subsequents should have their versions updated (i.e., using
       \inlinecode{Version::operator+()} and \inlinecode{DependencyHandle::set_version()}) to incorporate the fetched base version.
     
\paragraph{Parameters:}
\begin{compactdesc} 
\item[handle] A (non-owning) pointer to a \inlinecode{DependencyHandle} for which it must be valid to call \inlinecode{get_key()}
     but for which the return value of \inlinecode{get_version()} is ignored.
     
\item[user\_version\_tag] A Key to be used to match a publication version of the same key reported
       by \inlinecode{handle->get_key()} published elsewhere.
     
\item[write\_access\_allowed] A boolean indicating that the handle is allowed to occupy a write role in
       a task; i.e., \inlinecode{t.needs_write_data(handle)} can return true for up to one Task \inlinecode{t} registered with this instance.
       It is the responsibility of the frontend to ensure (either through semantics or user responsibility) that
       \inlinecode{register_handle()} is not called with a handle to the same key and the same version tag and
       \inlinecode{write_access_allowed=true} more than once {\bf globally}.  To do so is a debug mode error/optimized mode
       undefined behavior.  Also, if a \inlinecode{frontend::Task} instance returns true for \inlinecode{Task::needs_write_data()}
       on a handle that was registered with \inlinecode{write_access_allowed=false}, a debug mode error should be raised
       (undefined behavior is allowed in optimized mode).
\end{compactdesc}
     
\paragraph{Remarks:} For the 0.2.0 spec implementation, \inlinecode{write_access_allowed} should always be false


\subsubsection{release\_read\_only\_usage()}
\begin{CppCode}
    virtual void
    release_read_only_usage(
      const handle_t* const handle
    ) =0;
\end{CppCode}

\paragraph{Brief description:} Release the ability to create tasks that depend on handle as read-only.  The handle can
     then only be used up to once more in a (read-)write context before it is released.
     All handles can be used in a write context (i.e., be part of the return for \inlinecode{Task::get_dependencies()}
       for a task that returns true for \inlinecode{needs_write_data()} on that handle) at *most* once in their lifetime
       (from \inlinecode{register_handle()}/\inlinecode{register_fetching_handle()} to \inlinecode{release_handle()}).  This (up to) one "final"
       usage must run after all read-only uses of the handle; however not all read-only uses of
       a handle need to be registered by time the task making the "final" usage is registered.  Thus,
       the frontend needs to indicate when no more read-only usages will be created, thus allowing
       the "final" usage to clear its antidependencies.
       This method indicates that no more tasks will be registered that use handle in a read context
       but not in a write context (a maximum of one task may use handle in a write context anyway).
       The frontend may choose to call this after all tasks making read uses have *finished*, but this
       is not a requirement currently.  It must be called for all handles before \inlinecode{release_handle()} is
       called.  It is an error to call \inlinecode{release_handle()} on a handle before calling \inlinecode{release_read_only_usage()}.
     
\paragraph{Parameters:}
\begin{compactdesc} 
\item[handle] a non-owning pointer to a \inlinecode{DependencyHandle} for which \inlinecode{register_handle()} or
     \inlinecode{register_fetching_handle()} has been called on this instance but for which \inlinecode{release_handle()} has not
       yet been called.
\end{compactdesc}


\subsubsection{release\_handle()}
\begin{CppCode}
    virtual void
    release_handle(
      const handle_t* const handle
    ) =0;
\end{CppCode}

\paragraph{Brief description:} Release a previously registered handle, indicating that no more tasks will be registered
       with \inlinecode{handle} as an output (at least using the instance registered with \inlinecode{register_handle()}).
     
\paragraph{Parameters:} 
\begin{compactdesc}
\item[handle] A (non-owning) pointer to the same object with which \inlinecode{Runtime::register_handle()} (or
       \inlinecode{register_fetching_handle()}) was previously invoked.  Any (frontend or backend) uses of \inlinecode{handle}
       after \inlinecode{release_handle()} is returns are invalid and result in undefined behavior.  Upon release,
       if the handle has been published with \inlinecode{Runtime::publish_handle()} or if the handle was registered
       as the last subversion at a given depth using \inlinecode{Runtime::handle_done_with_version_depth()}, the
       appropriate action(s) should be taken to satisfy dependencies requiring data from the data block
       in \inlinecode{handle} (i.e., the return value of \inlinecode{handle->get_data_block()}).  If neither of these uses have
       been performed at the time of release, it is safe for the runtime to garbage collect the data block
       returned by \inlinecode{handle->get_data_block()}.
\end{compactdesc}


\subsubsection{handle\_done\_with\_version\_depth()}
\begin{CppCode}
    virtual void
    handle_done_with_version_depth(
      const handle_t* const handle
    ) =0;
\end{CppCode}

\paragraph{Brief description:} Indicate that no further subversions at the current version depth will be created.
     Essentially, this establishes a satisfy-upon-release relationship between \inlinecode{handle} and a handle
      with the subsequent of the penultimate subversion of handle.  In other words, if \inlinecode{handle} has
       version a.b.c.d (for some values a, b, c, and d of incrementable type, e.g., integers), then this
      indicates to the runtime that a call to \inlinecode{Runtime::release_handle()} on \inlinecode{handle} should lead to a
       call of (for some handle \inlinecode{h2} with the same key and version a.b.(++c)):
          \inlinecode{h2->satisfy_with_data_block(handle->get_data_block());}
       where \inlinecode{h2} must be registered at the time of that \inlinecode{Runtime::handle_done_with_version_depth()} is invoked
       on \inlinecode{handle}.  If no such handle is registered and no publications of handle have been made at the time
       of this invocation, the runtime is free to garbage collect the data block upon release.  Registering a
       handle with a version subsequent to the penultimate version of \inlinecode{handle} between this invocation and
       the release of handle will lead to undefined behavior.


\subsubsection{publish\_handle()}
\begin{CppCode}
    virtual void
    publish_handle(
      const handle_t* const handle,
      const Key& version_tag,
      const size_t n_fetchers = 1,
      bool is_final = false
    ) =0;
\end{CppCode}

\paragraph{Brief description:} Indicate to the backend that the key and version reported by \inlinecode{handle} should be fetchable
       with the user version tag \inlinecode{vertion_tag} exactly \inlinecode{n_additional_fetchers} times.
       In other words, \inlinecode{Runtime::register_fetching_handle()} must be called exactly \inlinecode{n_fetchers} times
       {\bf globally} with the key reported by \inlinecode{handle} and the \inlinecode{version_tag} given here before the runtime
       can overwrite or delete the data associated with the key and version reported by \inlinecode{handle}.

\paragraph{Parameters:} 
\begin{compactdesc}
\item[handle] A (non-owning) pointer to a \inlinecode{DependencyHandle} registered with \inlinecode{register_handle()} but
       not yet released with \inlinecode{release_handle()}.  The handle must have been registered with \inlinecode{write_access_allowed=true}.
\item[version\_tag] A user-space tag to be associated with the internal version reported by handle
       and to be fetched as such
\item[n\_fetchers] The number of times \inlinecode{register_fetcher()} must be called globally (and the corresponding
      fetching handles released) before antidependencies on \inlinecode{handle} are cleared.
\item[is\_final] Whether or not the publish is intented to indicate the key and data associated with
       handle are to be considered globally read-only for the rest of its lifetime.  If true, it is a (debug-mode)
       error to register a handle (anywhere) with the same key and a version \inlinecode{v > handle->get_version()}
\end{compactdesc}


\subsubsection{satisfy\_handle()}
\begin{CppCode}
    virtual void
    satisfy_handle(
      handle_t* const to_fill,
      bool needs_write_access = false
    ) =0;
\end{CppCode}


\subsubsection{establish\_containment\_relationship()}
\begin{CppCode}
    virtual void
    establish_containment_relationship(
      const handle_t* const inner_handle,
      const handle_t* const outer_handle,
      containment_manager_t const& manager
    ) =0;
\end{CppCode}

\subsubsection{establish\_aliasing\_relationship()}
\begin{CppCode}
    virtual void
    establish_aliasing_relationship(
      const handle_t* const handle_a,
      const handle_t* const handle_b,
      aliasing_manager_t const& manager
    ) =0;
\end{CppCode}

\subsubsection{finalize()}
\begin{CppCode}
    virtual void
    finalize() =0;
\end{CppCode}

\paragraph{Brief description:} Signifies the end of the outer SPMD task from which \inlinecode{darma_backend_initialize()} was called.
     



\subsection{{data\_block}}
\subsection{{types}}

\section{Front end Classes}
\todo[inline]{need better section title}
\todo[inline]{Add detail about how this is the interface that the back end has
into the front end and translation layer}
\todo[inline]{Add subsection for each class}

