%!TEX root = sandReportSpec.tex

\appendix


\chapter{Examples}
\label{chap:examples}


\section{Basic functionalities for spec 0.2}

\subsection{Example}
Example showing initialization and finalize of the DARMA environment.
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/0.2/spec02individualFunctionalities/initAndFinalize.cc}

\subsection{Example}
Example showing DARMA rank and size.
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/0.2/spec02individualFunctionalities/rankAndSize.cc}

\subsection{Example}
Example showing create work.
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/0.2/spec02individualFunctionalities/cw1.cc}

\subsection{Example}
Example showing the use of initial access.
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/0.2/spec02individualFunctionalities/initialAccess.cc}

\subsection{Example}
Another example on initial access handle and its usage.
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/0.2/spec02individualFunctionalities/accessHandle1.cc}

\subsection{Example}
Example showing the arrow operator on an handle.
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/0.2/spec02individualFunctionalities/accessHandleArrowOperator.cc}

\subsection{Example}
Example showing create work constraining privileges on a handle to be read-only.
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/0.2/spec02individualFunctionalities/cwReadsArg.cc}





\section{Hello World}

Example for one possible implementation of ``hello world''. 
There are three main parts involved: 
\begin{enumerate}
\item the DARMA environment is initialized. 
\item each rank creates a task to store a greeting message into a string
\item each rank then creates a task to printing to standard output the message and its rank.
\end{enumerate}
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/0.2/darma_hello/darma_hello.cc}





\section{Key-Value Example}

This example is to illustrate simple transactions with the keyvalue store, 
but in a distributed setting. We will ask each rank to publish a float to be
read by two readers, a rank on the left and one on the right. Then we will ask
each rank to get two floats, those published by the left and right neighbors
and print to screen. Periodic logic for neighbors, and each rank publishes a 
float that uniquely determines its rank.

\lstinputlisting[style=CppCodeNumbstyle]{../../examples/0.2/simple_kv/publish_get_parallel.cc}







\subsection{Publishing and read access}

This example explains in more detail the use of \texttt{publish} 
and \texttt{read\_access}. The example involves two DARMA ranks, each creating 
data, publishing it, and then fetching the other rank's data.

\lstinputlisting[style=CppCodeNumbstyle]{../../examples/0.2/spec02individualFunctionalities/publishAndReadAccess.cc}






\section{Publishing, versioning and lifetime of handles}

Lifetime of handles is tricky, particularly for \texttt{read\_access} type handles.  
In the following example, we initialize data, publish it, fetch it from another rank, 
modify the data, publish it again under a new version, and then fetch the new version from another rank. 
The \texttt{create\_work} on lines $40-44$ can't execute until the back end knows the first fetched version is done.
We put an extra set of \texttt{\{ \}} around the code in lines $28-36$ to tell the back end that 
the \texttt{readHandle} is no longer needed and can go out-of-scope and the fetching is done.  
Without the scoping \texttt{\{\}}, the code would deadlock. This is because the back end would not know that 
the fetching is done until after \texttt{darma\_finalize()} is called. However, \texttt{darma\_finalize()} 
can't return until after {\it all} the \texttt{create\_works} have completed.  And so the code would deadlock. 
Scoping is in this case necessary, but it is only useful in other cases to improve efficiency and parallelism 
in the scheduling and execution of tasks. Scoping is a good programming practice.


\lstinputlisting[style=CppCodeNumbstyle]{../../examples/0.2/spec02individualFunctionalities/version.cc}







\section{1D Poisson Equation}

Boundary value problem:

\begin{equation} 
  \frac{\partial^2 u(x)}{\partial x^2} = f(x) \quad 
  \text{in} \ \Omega=(0,1), \ \text{with} 
  \ u(0)=0, \ u(1)=\exp{(1)}\sin{(1)}
\end{equation} 
where $f(x)=2\exp{(x)}\sin{(x)}$. This problem is chosen because 
it has an exact solution, namely $u_{exact} = \exp{(1)}\sin{(1)}$. 
The exact solution will be used for checking the correctness 
of the code.

Discretize the domain with $N$ equally spaced points such that 
\begin{equation}
u_i \approx u(x_i), \quad f_i=f(x_i) 
\quad x_i = i \Delta x, \ \Delta x=\frac{1}{N-1}, \ \ i=0,1,...,N-1
\end{equation}
Use central difference approximation for the second derivative 
for all interior points:
\begin{large}
\begin{equation}
\begin{cases}
  \frac{u_{i+1} - 2u_i + u_{i-1}}{(\Delta x)^2}=f_i, & \text{for } i=1,...,N-2 \\
    u_0=0, \ u_{N-1}=\exp{(1)}*\sin{(1)} & \text{Dirichlet BC}
\end{cases}  
\end{equation}
\end{large}

This translates to a linear system of equations $Au=f$ 
where $A$ is an $N-2 \times N-2$ tridiagonal matrix 
\begin{equation}
A = \begin{vmatrix}
-2 & 1 \\
1 & -2 & 1 \\
& 1 & -2 & 1 \\
& & \ddots & \ddots & 1 \\
& & & 1 & -2
\end{vmatrix}.
\end{equation}

and $u$ is the unknown, and $f$ is the right-hand-side. 
Both $u$ and $f$ have size $N-2$. 
Solving this linear system yields the solution at all the inner 
points of the domain. For demonstration purposes, we solve 
this system using Thomas algorithm, a method well-suited 
for tridiagonal systems. 
The solver needs these vectors:
\begin{enumerate}
\item $a$: contains all the sub-diagonal entries. 
\item $b$: contains all the diagonal entries. 
\item $c$: contains all the upper-diagonal entries. 
\item $d$: contains all the right-hand-side entries. 
Also, our current version of the solver is 
such that on exit, the vector $d$ contains the solution.
\end{enumerate}

How to implement this in DARMA? 
For demonstration purposes, we limit our attention to the case 
of a single rank. More complex examples will be shown below 
involving multiple ranks.

There are three main steps involved, namely initialization, 
solution of the linear system, and error check. 
The DARMA main file is as follows:
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/0.2/poisson_1d_thomasAlgorithm/single_rank/single_rank.cc}

The header file constants.h contains:
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/0.2/poisson_1d_thomasAlgorithm/constants.h}

The initialization function has the form:
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/0.2/poisson_1d_thomasAlgorithm/single_rank/initialize.h}

The function to solve the linear system is:
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/0.2/poisson_1d_thomasAlgorithm/single_rank/solveTridiag.h}

Finally, we check for convergence by checking the $L1$-norm of the 
error between the computed and true solution.
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/0.2/poisson_1d_thomasAlgorithm/single_rank/checkError.h}







