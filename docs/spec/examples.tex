%!TEX root = sandReportSpec.tex

\appendix


\chapter{Examples}
\label{chap:examples}



\section{Basic functionalities for spec 0.2}


\subsection{Example}
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/spec02individualFunctionalities/initAndFinalize.cc}

\subsection{Example}
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/spec02individualFunctionalities/rankAndSize.cc}

\subsection{Example}
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/spec02individualFunctionalities/cw1.cc}

\subsection{Example}
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/spec02individualFunctionalities/initialAccess.cc}

\subsection{Example}
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/spec02individualFunctionalities/accessHandle1.cc}

\subsection{Example}
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/spec02individualFunctionalities/accessHandleArrowOperator.cc}

\subsection{Example}
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/spec02individualFunctionalities/cwReadsArg.cc}



\subsection{Publishing and read access}

First example is basic and explains in more detail the use of \texttt{publish} 
and \texttt{read\_access}. The example involves two DARMA ranks, each creating 
data, publishing it, and then fetching the other rank's data.

\lstinputlisting[style=CppCodeNumbstyle]{../../examples/spec02individualFunctionalities/publishAndReadAccess.cc}





\section{Publishing, versioning and lifetime of handles}

Lifetime of handles is tricky, particularly for \texttt{read\_access} type handles.  
In the following example, we initialize data, publish it, fetch it from another rank, 
modify the data, publish it again under a new version, and then fetch the new version from another rank. 
The \texttt{create\_work} on lines $40-44$ can't execute until the back end knows the first fetched version is done.
We put an extra set of \texttt{\{ \}} around the code in lines $28-36$ to tell the back end that 
the \texttt{readHandle} is no longer needed and can go out-of-scope and the fetching is done.  
Without the scoping \texttt{\{\}}, the code would deadlock. This is because the back end would not know that 
the fetching is done until after \texttt{darma\_finalize()} is called. However, \texttt{darma\_finalize()} 
can't return until after {\it all} the \texttt{create\_works} have completed.  And so the code would deadlock. 
Scoping is in this case necessary, but it is only useful in other cases to improve efficiency and parallelism 
in the scheduling and execution of tasks. Scoping is a good programming practice.


\lstinputlisting[style=CppCodeNumbstyle]{../../examples/spec02individualFunctionalities/version.cc}







\section{1D Poisson Equation}

Boundary value problem:

\begin{equation} 
  \frac{\partial^2 u(x)}{\partial x^2} = f(x) \quad 
  \text{in} \ \Omega=(0,1), \ \text{with} 
  \ u(0)=0, \ u(1)=\exp{(1)}\sin{(1)}
\end{equation} 
where $f(x)=2\exp{(x)}\sin{(x)}$. This problem is chosen because 
it has an exact solution, namely $u_{exact} = \exp{(1)}\sin{(1)}$. 
The exact solution will be used for checking the correctness 
of the code.

Discretize the domain with $N$ equally spaced points such that 
\begin{equation}
u_i \approx u(x_i), \quad f_i=f(x_i) 
\quad x_i = i \Delta x, \ \Delta x=\frac{1}{N-1}, \ \ i=0,1,...,N-1
\end{equation}
Use central difference approximation for the second derivative 
for all interior points:
\begin{large}
\begin{equation}
\begin{cases}
  \frac{u_{i+1} - 2u_i + u_{i-1}}{(\Delta x)^2}=f_i, & \text{for } i=1,...,N-2 \\
    u_0=0, \ u_{N-1}=\exp{(1)}*\sin{(1)} & \text{Dirichlet BC}
\end{cases}  
\end{equation}
\end{large}

This translates to a linear system of equations $Au=f$ 
where $A$ is an $N-2 \times N-2$ tridiagonal matrix 
\begin{equation}
A = \begin{vmatrix}
-2 & 1 \\
1 & -2 & 1 \\
& 1 & -2 & 1 \\
& & \ddots & \ddots & 1 \\
& & & 1 & -2
\end{vmatrix}.
\end{equation}

and $u$ is the unknown, and $f$ is the right-hand-side. 
Both $u$ and $f$ have size $N-2$. 
Solving this linear system yields the solution at all the inner 
points of the domain. For demonstration purposes, we solve 
this system using Thomas algorithm, a method well-suited 
for tridiagonal systems. 
The solver needs these vectors:
\begin{enumerate}
\item $a$: contains all the sub-diagonal entries. 
\item $b$: contains all the diagonal entries. 
\item $c$: contains all the upper-diagonal entries. 
\item $d$: contains all the right-hand-side entries. 
Also, our current version of the solver is 
such that on exit, the vector $d$ contains the solution.
\end{enumerate}

How to implement this in DARMA? 
For demonstration purposes, we limit our attention to the case 
of a single rank. More complex examples will be shown below 
involving multiple ranks.

There are three main steps involved, namely initialization, 
solution of the linear system, and error check. 
The DARMA main file is as follows:
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/poisson_1d_thomasAlgorithm/single_rank/single_rank.cc}

The header file constants.h contains:
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/poisson_1d_thomasAlgorithm/constants.h}

The initialization function has the form:
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/poisson_1d_thomasAlgorithm/single_rank/initialize.h}

The function to solve the linear system is:
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/poisson_1d_thomasAlgorithm/single_rank/solveTridiag.h}

Finally, we check for convergence by checking the $L1$-norm of the 
error between the computed and true solution.
\lstinputlisting[style=CppCodeNumbstyle]{../../examples/poisson_1d_thomasAlgorithm/single_rank/checkError.h}







