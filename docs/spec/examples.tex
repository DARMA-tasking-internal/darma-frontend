%!TEX root = sandReportSpec.tex

\chapter{Examples}
\label{chap:examples}




\subsection{Publish and read access}

\begin{CppCodeNumb}
#include <darma.h>
int darma_main(int argc, char** argv)
{
  using namespace darma_runtime;
  using namespace darma_runtime::keyword_arguments_for_publication;

  darma_init(argc, argv);
  const int myRank = darma_spmd_rank();
  const int size = darma_spmd_size();

  // supposed to be run with 2 ranks, so ignore the rest
  assert(size>=2);
  if (myRank>=2){
    darma_finalize();
    return 0;
  }

  // rank0 reads from source = rank1 
  // rank1 reads from source = rank0 
  int source = myRank==0 ? 1 : 0;

  auto my_handle = initial_access<double>("data", myRank);
  create_work([=]
  {
    my_handle.emplace_value(0.5 + (double) myRank);

    // n_readers == 1 because: 
    //  rank0 reads data of rank1
    //  rank1 reads data of rank0
    my_handle.publish(n_readers=1);
  });

  AccessHandle<double> readHandle = read_access<double>("data", source);
  create_work([=]
  {
    std::cout << myRank << " " << readHandle.get_value() << std::endl;
    if (myRank==0)
      assert( readHandle.get_value() == 1.5 );
    else
      assert( readHandle.get_value() == 0.5 );
  });

  darma_finalize();
  return 0;
}
\end{CppCodeNumb}






\section{Publish, versioning and lifetime of handles}

Lifetime of handles is tricky, particularly for \texttt{read\_access<T>()} handle.  
In the following example, we initialize data, publish it, fetch it from another rank, 
modify the data, publish it again under a new version, and then fetch the new version from another rank. 
The \texttt{create\_work} on lines $40-44$ can't execute until the backend knows you're done with the first fetched version. 
We put an extra set of \texttt{\{ \}} around the readaccess+creatework in lines $28-36$ to tell the backend that 
the \texttt{readHandle} is no longer needed and can go out-of-scope and the fetching is done.  
Without the scoping \texttt{\{\}}, the code would deadlock. THis is because the backend would not know that 
the fetching is done until after \texttt{darma\_finalize()} is called. However, \texttt{darma\_finalize()} 
can't return until after {\it all} the \texttt{create\_works} have completed.  And so the code would deadlock. 


\begin{CppCodeNumb}
#include <darma.h>
int darma_main(int argc, char** argv)
{
  using namespace darma_runtime; 
  using namespace darma_runtime::keyword_arguments_for_publication;
  darma_init(argc, argv);
  const int myRank = darma_spmd_rank();
  const int size = darma_spmd_size();

  // supposed to be run with 2 ranks, so ignore the rest
  assert(size>=2);
  // rank0 reads from source = rank1, rank1 reads from source = rank0 
  int source = myRank==0 ? 1 : 0;

  // create data
  auto my_handle = initial_access<double>("data", myRank);
  create_work([=]
  {
    my_handle.emplace_value(0.5 + (double) myRank);
    my_handle.publish(n_readers=1,version=0); // n_readers == 1
  });

  /* scope {} needed here and useful because it tells backend that 
     readHandle will go outofscope and so backend has more detailed 
     info and this can benefit parallelism and execution. 
     In other words, one should scope things whenever it is possible. */ 
  {
    auto readHandle = read_access<double>("data", source,version=0);
    create_work([=]
    {
      std::cout << myRank << " " << readHandle.get_value() << std::endl;
      if (myRank==0)
        assert( readHandle.get_value() == 1.5 );
      else
        assert( readHandle.get_value() == 0.5 );
    });
  }

  // reset value and update version
  create_work([=]
  {
    my_handle.set_value(2.5 + (double) myRank);
    my_handle.publish(n_readers=1,version=1);
  });

  // second time reading
  auto readHandle2 = read_access<double>("data", source,version=1);
  create_work([=]
  {
    std::cout << myRank << " " << readHandle2.get_value() << std::endl;
    if (myRank==0)
      assert( readHandle2.get_value() == 3.5 );
    else
      assert( readHandle2.get_value() == 2.5 );
  });

  darma_finalize();
  return 0;
}
\end{CppCodeNumb}





\subsection{1D Poisson Equation or 1D Heat}

To complete





