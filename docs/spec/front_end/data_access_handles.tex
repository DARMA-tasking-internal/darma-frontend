%!TEX root = ../sandReportSpec.tex


%\lstMakeShortInline[style=CppCodeInlineStyle]{\|}
\section{Data Access Handles}
\label{sec:handles}
\codetarget{AccessHandle<T>} objects are lightweight wrappers around the actual data structure of interest having type T. 
The handles add a control block (metadata) that tracks uses of the handle and enforces
\gls{sequential semantics}, analogous to smart pointers that wrap pointer types and provide a reference counting control block.
Critically, this interface is non-intrusive, wrapping any type T without requiring that type to be modified.

Most critically, \ahandle enables deferred access since \ahandle can exist in ready or pending states. 
Ready and pending are not rigorously defined in the state table for \ahandle in
Section \ref{sec:handlerules},
but rather guiding concepts.
Ready handles can be dereferenced (have their underlying values fetched) and be used immediately to perform work.
Pending handles cannot be dereferenced, but can still be used to \emph{schedule} or \emph{instantiate} work.
Thus even if a handle is carrying pending or unresolved data, execution can advance thereby unrolling more of the task graph.
This \emph{lookahead} is the key element that enables runtime optimizations.
Lookahead gives the runtime more complete knowledge of the task graph instead of locally executing step-by-step.
By looking ahead, the runtime can reorder or migrate tasks to maximize data locality and improve load balance.
The most critical conceptual change from standard C++ to DARMA are pending variables that enable lookahead, unlike conventional C++ variables that must always be ``ready''.

Handles can be created three different ways.
\begin{enumerate}
\item a handle to data that does not yet exist in the system
but needs to be created, or
\item a handle to data produced by another process that needs to
be read, or 
\item a handle to data produced by another process that needs to be overwritten or modified. 
Note that this type of handle does not exist in the current version of the spec.
\end{enumerate}

Type 1 is denoted as \inlinecode{initial_access} in DARMA, 
which informs the runtime that the data with the 
specified key does not yet exist, and the user intends to 
create this data.% and (potentially) publish it.
Hence, an \inlinecode{initial_access} data handle is usually 
followed by a memory allocation, and a value assignment. 
Remark: Although we could explicitly write out \ahandleT in the code below,
we \emph{strongly encourage} programmers to use the C++ \inlinecode{auto} keyword.
It will greatly increase code portability for future (potentially backwards-incompatible) versions of DARMA,
with the additional benefit of decreasing code verbosity.

\begin{CppCode}
auto float_handle = initial_access<float>("float_key");
create_work([=]{
  float_handle.set_value(3.14);
});
\end{CppCode}
As stated above, DARMA provides two methods for expressing task preconditions: sequential semantics and coordination.
\inlinecode{initial_access} is necessary in both methods.
Once created, a handle can be passed along to subtasks within the same, sequential execution stream.
A handle created by \inlinecode{initial_access} can also be published, making it available to other execution streams via key-value store coordination.

Handles of Type 2 above request read-only access to data produced externally in the system through \inlinecode{read_access}. 
As such, \inlinecode{read_acccess} is only relevant for applications that use coordination to express data flow.
\begin{CppCode}
auto float_handle = read_access<float>("another_float_key");
create_work([=]{
  float val = float_handle.get_value();
  std::cout << "Value read with key another_float_key is " << val;  
});
\end{CppCode}

Immediately following the \inlinecode{read_access} function, the \ahandle will be \emph{pending} instead of \emph{ready}.
To enable \inlinecode{get_value} to be called (put the handle in a ready state), the handle must be used inside of a \inlinecode{create_work}.
\cwork defers execution of the code block until they key-value store resolves the value of \inlinecode{float_handle} and converts it to a ready state.
This might involve moving data if the \inlinecode{float} is on a remote node.
Remark: future versions of DARMA will enable tasks to begin optimistically with some handles still in a pending state, but this is not supported in the current version.

In general, any calls to \inlinecode{get_value} should occur 
within a scoped code block to avoid dangling references to stale physical memory locations.
%Even when it becomes possible to wait on the data associated with a handle (in
%later versions of the spec), best practice is to access data via deferred tasks
inside a \inlinecode{create_work} block when possible.

Tasks should only ever request the privileges they need. 
Over-requesting privileges will limit the amount of available parallelism in the code.
A task may be using a handle with read-write privileges created by \inlinecode{initial_access}
and then create a subtask that requires only read privileges.
\todo[inline]{The paragraph above would make more sense after discussing handle usage rules at least briefly.}


\begin{CppCode}
auto float_handle = initial_access<float>("yet_another_float_key");
....
create_work(reads(float_handle), [=] {
  std::cout << "Value read with key yet_another_float_key is " 
          << float_handle.get_value() << std::endl;
})
create_work(reads(float_handle), [=] {
  float val = float_handle.get_value();
  if (val > 0) std::out << "Value is positive" << std::end;
})
//read-write work down here
\end{CppCode}
In this case, subtasks are created that only need read access. 
Without the \inlinecode{reads} qualifier, these tasks could not run in parallel (or out-of-order) since they
would by default request read-write privileges.
Sequential semantics would then require them to write in-order sequentially.

\subsection{Publish}
\label{subsec:publish}
By default, unless explicitly published, data handles are visible only to tasks
within the same scope (tasks that have a copy of the actual
\ahandleT object, created as discussed in
Section \ref{sec:handles}).
For data to be globally visible in the global memory space (key-value store),
the application developer must explicitly \inlinecode{publish} data.  
Unpublished data will be reclaimed once the last handle referencing it goes out of scope (i.e refcount goes to zero),
freeing the memory and resolving any anti-dependencies analogous to the
destructor invocation in C++ when a class goes out of scope.  
Unpublished data can leverage the sequential semantics of the application for garbage collection.  
Published data, however, is globally visible to all workers and requires more ``permanence.''  
In order to reclaim the data (garbage collect or resolve anti-dependence), published data must know its access group.
When all read handles within an access group have been deleted or released \emph{globally}, the published data can be reclaimed.
The easiest way to declare an access group (and currently supported method) is
to simply give the total number of additional read \ahandleT objects that will be created referring to it.
In future versions, hints will be supported about which specific tasks will need to read data.
The publish/fetch mechanism replaces an analogous \inlinecode{MPI_Send/Recv} or even potentially an \inlinecode{MPI_Bcast}.
In MPI, these function calls force an \inlinecode{MPI_Send} or \inlinecode{MPI_Wait} to block until the runtime guarantees that the data has been delivered.
An access group in DARMA provides a similar guarantee.
Until all readers in an access group have received or released their data, DARMA cannot reclaim (garbage collect, clear anti-dependencies).

\begin{CppCode}
auto float_handle = initial_access<float>("float_key");
create_work([=]{
  float_handle.set_value(3.14);
});
float_handle.publish(n_readers=1);
\end{CppCode}
The \inlinecode{n_readers} specification in the publish call is a keyword
argument (see Section \ref{sec:keyword}) that informs the runtime that the data
(associated with \inlinecode{float_key}) will only ever be read once, and hence can be safely garbage collected soon after.  
This code provides similar functionality to send/receive.

As discussed above, handles can either be ready or pending. 
In reality, the distinction is more subtle. 
The ``readiness'' and ``pendingness'' can be different for read usages and write usages.
Thus a handle can be read-ready, but modify-pending.
This will be the case after publish operations.
Publish operations are treated as asynchronous read operations --- that is,
\inlinecode{h.publish(...)} is equivalent to
\begin{CppCode}
create_work(reads(h), [=]{...});  
\end{CppCode}
This means that the same precautions should be taken as with asynchronous reads. 
In particular, even if the handle was ready for modifying before
\inlinecode{publish}, it is no longer valid to call \inlinecode{h.set_value()} after the publish.
The asynchronous read done by the publish may or may not have occurred yet.  
In this scenario, one should use instead
\begin{CppCode}
create_work([=]{ h.set_value(...); });
\end{CppCode}
to force the handle from a pending state to a ready state.

\subsubsection{Publication Versions}
If a handle is going to be published multiple times (or, more specifically, if
the key with which the handle was created is going to be published multiple
times), it needs to be published with a different version each time.  
Versions are just like keys --- an arbitrary tuple of values (see Section \ref{subsec:keys}).  
For instance:

\begin{minipage}{0.5\textwidth}
\begin{CppCode}
/** Execution stream 0 */
auto float_h =
  initial_access<float>("float_key");
auto int_h =
  initial_access<int>("int_key");
/* Execution stream 1 */
int_h.publish(n_readers=3, version=77);
//Use version() for multiple parts
float_ha.publish(n_readers=1, 
    version("alpha",42));
\end{CppCode}
\end{minipage}
\begin{minipage}{0.45\textwidth}
\begin{CppCode}
/* Execution stream 1*/
auto my_int =  read_access<int>(
  "int_key", version=77);
auto my_float = read_access<float>(
  "float_key", version("alpha",42));
\end{CppCode}
\end{minipage}

Versions have similarities with MPI tags to ensure the uniqueness of data.
However, unlike MPI which uses a combination of message order and tag to uniquely identify messages and match send/recv pairs,
the DARMA asynchronous model does not allow implicit publication order to be used in matching publish/read pairs.
Instead, all publications must uniquely identify each publication with a specific version.


\subsection{Keys}
\label{subsec:keys}
In the examples in this section, the \inlinecode{key} to the
\ahandleT has always been a single string. 
A \inlinecode{key} in DARMA 
can be an arbitrary \gls{tuple} of values.  This 
makes it very easy for the application developer to create an expressive
and descriptive \inlinecode{key} for each piece of data.  Tuples can comprise
different bit-wise copiable data types.  The example at the end of
Section~\ref{sec:spmd} illustrates the use of the \gls{rank} within the handle
\inlinecode{key}.  The following example shows the use of an
aribitrary \gls{tuple} as a \inlinecode{key}:
\begin{CppCode}
  int neighbor_id
  double other_identifier;

  // some code that sets neighborID and other_identifier
  
  auto float_handle = initial_access<float>("float_key", 
                                            neighbor_id, 
                                            other_identifier);
\end{CppCode}

\subsection{Handle Usage Rules}
\label{sec:handlerules}
Handles are assigned states, and these states change 
based on the operations applied to them.  
As discussed above, the state of a handle encompasses both its read/write permissions and its ``readiness."
Pending handles can only be used for scheduling tasks while ready handles can be immediately used to do work.
We more rigorously divide permissions into two main categories: 
\begin{itemize}
\item[a] {\it Scheduling}: Permissions a handle may use when instantiating tasks with \inlinecode{create_work}.
These permissions apply independent of handle readiness. 
Generally, this will be Read (handle may only used in read-only tasks) or Modify (handle may be used in read-only or read-write tasks). 
\item[b] {\it Immediate}: Permissions that apply immediately, indicating the ``readiness'' of the handle.  Immediate privileges can ever be greater than Scheduling privileges.
A task can never have greater permissions doing immediate work than it can for instantiating deferred work.
\end{itemize}

For the two methods of creating handles, we have the following initializations.
\begin{itemize}
\item \inlinecode{initial_access<T>}: Initialized with scheduling modify, immediate none. 
The handle can be used in any mode when instantiating deferred work.
However, the handle is not necessarily initialized and as such cannot be used immediately for reads or writes.
%
\item \inlinecode{read_access<T>}: Initialized with scheduling read, immediate none.
The handle can only be used for reads when instantiating deferred work.
However, the handle is not necessarily initialized and as such cannot be used immediately.
\end{itemize}


In the parent task, a handle will have an initial pair of scheduling/immediate privileges (predecessor state).
After the call to create work, the handle's state will have changed, potentially losing some immediate privileges (continuing state).
As specified currently, execution does not begin inside the deferred work block until a handle becomes ready.
Inside the \cwork (capture state), the handle's immediate and scheduling privileges will therefore be the same.
Table \ref{tab:immsimp} summarizes the state transitions involving these three handles following \cwork.
\begin{CppCode}
//Predecessor parent state
create_work([=]{
  //Capture state
})
//Continuing parent state
\end{CppCode}

\begin{table}[!t]
\begin{center}
{\small
\begin{tabular}{cc|cc|cc}
 \hline
 \multicolumn{2}{c|}{Predecessor State}
 & \multicolumn{2}{c|}{\inlinecode{get_value()}} 
 & \multicolumn{2}{c}
 {
    \specialcell{ \inlinecode{emplace_value()} \\ 
                  \inlinecode{set_value()}\\
                  \inlinecode{get_reference()}\\
                  } 
 } 
  \\
 \hline
 \specialcell{Scheduling\\ permissions} 
 & \specialcell{Immediate\\ permissions}  
 & { {\footnotesize Allowed? } } \hspace{-0.cm} & { {\footnotesize Continuing as}}
 & { {\footnotesize Allowed? } } \hspace{-0.cm} & { {\footnotesize Continuing as}}
 \\
 \hline
 None & None
 & No & -
 & No & -
 \\
 %
 Read & None
 & No & -
 & No & -
 \\
 %
 Read & Read
 & Yes & {\em Read/Read}
 & No & -
  \\
 %
 Modify & None
 & No & -
 & No & -
 \\
 %
 Modify & Read
 & Yes & {\em Modify/Read}  
 & No & -
  \\
 %
 Modify & Modify
 & Yes & {\em Modify/Modify}  
 & Yes & {\em Modify/Modify}  
  \\
\hline
\end{tabular}
}
\caption{Operations on the various states}
\label{tab:immsimp}
\end{center}
\end{table}
%
\begin{table}[!t]
\begin{center}
{\small
\begin{tabular}{cc|ccc|ccc}
 \hline
 \multicolumn{2}{c|}{Predecessor State} 
 & \multicolumn{3}{c|}{\em{read-only capture} and publish} 
 & \multicolumn{3}{c}{\em{modify capture}}  \\
 \hline
 \specialcell{Scheduling\\ permissions} 
 & \specialcell{Immediate\\ permissions}  
 & {\footnotesize Allowed? } &  \specialcell{\footnotesize Capture\\Handle} 
 &  \specialcell{\footnotesize Continuing\\Handle} 
 & {\footnotesize Allowed? } &  \specialcell{\footnotesize Capture\\Handle} 
 &  \specialcell{\footnotesize Continuing\\Handle} \\
 \hline
 None & None & No & - & - & No & - & - \\
 %
 Read & None 
 & Yes 
 & {\em Read/Read}
 & {\em Read/None}
 & No
 & -
 & - \\
 %
 Read & Read
 & Yes 
 & {\em Read/Read}
 & {\em Read/Read}
 & No
 & -
 & - \\
 %
 Modify & None
 & Yes 
 & {\em Read/Read}
 & {\em Modify/None}
 & Yes
 & {\em Modify/Modify} 
 & {\em Modify/None} \\
 %
 Modify & Read
 & Yes 
 & {\em Read/Read}
 & {\em Modify/Read}
 & Yes
 & {\em Modify/Modify} 
 & {\em Modify/None} \\
 %
 Modify & Modify
 & Yes 
 & {\em Read/Read} 
 & {\em Modify/Read} 
 & Yes
 & {\em Modify/Modify}
 & {\em Modify/None} \\
\end{tabular}
}
\caption{Deferred (capturing) operations on the various states.}
\label{tab:capsimp}
\end{center}
\end{table}


To further illustrate, below is an \emph{incorrect} usage of modify privileges

\begin{minipage}[t]{0.45\linewidth}
\centering WRONG
\begin{vaspPseudo}
initial_access<int> a
//a is in Modify/None
a.set_value(1) $\no$ 
a.get_value()  $\no$
\end{vaspPseudo}
\end{minipage}
\begin{minipage}[t]{0.45\linewidth}
\centering CORRECT
\begin{vaspPseudo}
initial_access<int> a
//a is in Modify/None
create_work([=]{ //modify capture
    a.emplace_value(1)  $\yes$
    a.set_value(1)      $\yes$
    a.get_reference()=1 $\yes$
});
\end{vaspPseudo}
\end{minipage}


Additionally, we demonstrate an \emph{incorrect} usage of read privileges

\begin{minipage}[t]{0.45\linewidth}
\centering
\centering WRONG
\begin{vaspPseudo}
read_access<int> b
//b is in Read/None
b.get_value()   $\no$
b.set_value(1)  $\no$
create_work([=]{ //capture
  b.set_value(1) $\no$
});
\end{vaspPseudo}
\end{minipage}
\begin{minipage}[t]{0.45\linewidth}
\centering
\centering CORRECT
\begin{vaspPseudo}
read_access<int> b
//b is in Read/None
create_work([=]{ // capture
  b.get_value()  $\yes$
});
\end{vaspPseudo}
\end{minipage}



