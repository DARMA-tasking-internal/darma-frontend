%\lstMakeShortInline[style=CppCodeInlineStyle]{|}
\section{Deferred Work Creation}
\label{sec:deferred}
In an AMT \gls{runtime system}, the user creates blocks of work that
are executed when the proper permissions on the data they use are available.
In DARMA, \gls{deferred work}\footnote{``\Gls{deferred work}'' is one generic term we use for work
performed by code inside the capturing \gls{lambda} passed to the
\codelink{create_work} construct (as well as other deferred constructs which
may be added to future versions of the spec).  This does not necessarily imply
that the \gls{continuing context} (after the \codelink{create_work}) will be
executed before the \gls{captured work} (note that ``\gls{captured work}'' and
``\gls{captured context}'' are two other generic terms we use interchangeably
with \gls{deferred work}).  
In other words, if all of the permissions for executing the \gls{deferred work} are
available at the time of its creation, the \gls{runtime system} may choose to execute it
immediately.  It also may choose to block until the permissions are ready rather
than executing the \gls{continuing context}.  More details to follow.}
\todo{David: I modified the footnote slightly - please confirm
it is still correct.} is communicated
to the \gls{runtime system} via \codelink{create_work} function, which utilizes
the \CC{} \gls{lambda} mechanism to yield the following syntax:
% DSH merged [=]{ into one line for a couple of reasons; chief reason is we may
% want to macro this at some point so that it can conditionally be compiled into
% [=] __cuda_inline__ {  or something like that for GPU use.
\begin{CppCode}
  create_work([=]{
    // work to do
  });
\end{CppCode}

While this syntax leverages \CC{}11 \glspl{lambda}, the user does not need to
completely understand \CC{}11 standard features to use \codelink{create_work}
(this complexity is managed by DARMA's \gls{translation layer}, as summarized in
Chapter~\ref{chap:translation_layer}). All the work specified within a
\codelink{create_work} is queued for deferred execution, and will be run when
all of its \glspl{dependency} and \glspl{anti-dependency} are met.  
These \glspl{dependency} are determined from the use of 
\codelink{AccessHandle<T>} objects in the \gls{deferred context}. 
\codelink{AccessHandle<T>} objects are described in more detail below, in
Section \ref{sec:handles}.  In a basic sense, \glspl{handle} help maintain
\gls{sequential semantics} in the \gls{programming model}.  For instance, the
following code should print ``first: 42, second: 84'':
\begin{CppCode}
AccessHandle<int> my_handle = initial_access("some_data_key");
create_work([=]{
  my_handle.set_value(42);
});
create_work([=]{
  cout << "first: " << my_handle.get_value();
});
create_work([=]{
  my_handle.set_value(my_handle.get_value()*2);
});
create_work([=]{
  cout << ", second: " << my_handle.get_value();
});
\end{CppCode}
This intuitive way of coding is called \gls{sequential semantics}, 
and its use is pivotal to the DARMA \gls{programming model}.

% DSH took this out for now
% which manage the complexity necessary (within DARMA's
%\gls{translation layer}) to 1) preserve \gls{sequential semantics} within a \gls{rank}, while performing work asynchronously, and 2) |publish| data visibly outside a \gls{rank}.
%\Glspl{dependency} and \glspl{anti-dependency} for a 
%|create_work| are inferred by the runtime via
%\gls{introspection} (again, within the \gls{translation layer}). 
%The following simple example illustrates how |handles| and
%|create_work| can be used to gether in a simple ``hello world''
%example:
%\begin{CppCode}
%#include <darma.h>
%using namespace darma_runtime;
%using namespace darma_runtime::keyword_arguments_for_publication;
%
%int main(int argc, char** argv) {
%
%  darma_init(argc, argv);
%
%  size_t me = darma_spmd_rank();
%  size_t n_ranks = darma_spmd_size();
%
%  auto greetingMessage = initial_access<std::string>("myName", me);
%
%  create_work([=]
%  {
%    greetingMessage.set_value("hello world!");
%  });
%
%  create_work([=]
%  {
%    std::cout << "DARMA rank " << me << " says " 
%              << greetingMessage.get_value() << std::endl;
%  });
%
%  darma_finalize();
%
%}
%\end{CppCode}
%In this example, 1) the DARMA environment is initialized, 2) each rank creates
%% a task to store a greeting message into a string, and 3) each rank then creates a
%task to print the message and its rank to standard output.
%Note that, in this example, |publish| is not required as the
%dependency |greeting_message| is createed for each rank individually
%(i.e., none of the dependencies must be visible outside of its rank).
%In order to guarantee \gls{sequential semantics} (i.e., to make sure the value
%of |greetingMessage| is set before it is printed),
%|greetingMessage| must be a |handle|.

\todo[inline]{David:add functor interface text. This will involve updating the 
footnote in this section (for example, the definition of continuing context in
the footnote.  Also, the definition of continuing context may need to be
updated in the glosary as well... Please check. } 

%\lstDeleteShortInline{|}
