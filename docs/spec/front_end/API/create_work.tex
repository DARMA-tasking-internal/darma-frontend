%\clearpage
\subsection{\texttt{create\_work}}
\label{ssec:api_fe_cw}

\paragraph{Summary}\mbox{}\\
Expresses work to be executed by the runtime system.

\paragraph{Syntax}\mbox{}\\
\begin{CppCode}
// Functionally:
create_work([=]{
  // Code expressing deferred work goes here
});
// or:
create_work(
  ConstraintExpressions..., 
  [=]{
    // Code expressing deferred work goes here
  }
);

// Formally:
/* unspecified */ create_work(Arguments..., LambdaExpression);
\end{CppCode}

\paragraph{Positional Arguments}\mbox{}\\
\begin{itemize}
  \item |LambdaExpression| A C++11 lambda expression with a copy
  default-capture (i.e., |[=]|) and taking no arguments.  More details
  below.
  \item |ConstraintExpressions...| (optional) If given, these
  arguments can be used to express modifications in the default capture behavior
  of |AccessHandle<T>| objects captured by the |LambdaExpression|
  given as the final argument.  In the 0.2 spec, the only valid permission
  modification expression is the return value of the |reads()| modifier
  (see \S~\ref{ssec:api_fe_reads}), which indicates that only read operations
  are performed on a given handle or handles within the
  |LambdaExpression| that follows.
\end{itemize}


\paragraph{Return}\mbox{}\\
Currently |void| in the 0.2 spec, but may be an object of unspecified
type in future implementations.

\paragraph{Details}\mbox{}\\
This function expresses work to be executed by the runtime system.  Any
|AccessHandle<T>| variables used in the |LambdaExpression| will be
captured and made available inside the capturing context as if they were used in
sequence with previous capture operations on the same handle.  Depending on the
scheduling permissions available to the |AccessHandle<T>| at the time of
|create_work| invocation and on the |ConstraintExpressions...|
given as arguments, this function call expresses either a {\it read-only
capture} or a {\it modify capture} operation on a given handle (see
\S~\ref{sec:handlerules}).  If a handle |h| has {\it Read} scheduling
permissions when it is captured or if the explicit constraint expression
|reads(h)| is given in the |ConstraintExpressions...| arguments,
|create_work| functions as a {\it read-only capture} operation on that handle.
Otherwise, it functions as a {\it modify capture}.  

Additional general discussion on use of |create_work| can be found in
\S~\ref{sec:deferred}.


\paragraph{Code Snippet}\mbox{}\\
\begin{figure}[!h]
\begin{CppCodeNumb}
create_work([=]{
  std::cout << " Hello world! " << std::endl;
});
\end{CppCodeNumb}
\label{fig:fe_api_cw}
\caption{Basic usage of \texttt{create\_work}.}
\end{figure}


\paragraph{Restrictions and Pitfalls}\mbox{} \\
Most of the general restrictionsn and pitfalls related to |create_work|
are discussed in \S~\ref{sec:deferred}.  Some more technical restrictions are
given here.
\begin{itemize}
  \item Because of the way in which |create_work| is implemented, placement of
  multple |create_work| operations on the same line of code will not compile. 
  For instance:
  \begin{CppCode}
// $\no$ does not compile, gives cryptic error message
create_work([=]{}); create_work([=]{}); 
  \end{CppCode}
  This is particularly easy to accidentally do when defining preprocessor
  macros:
  \begin{CppCode}
// $\no$ does not compile, gives even more cryptic error message
#define foo(...) __VA_ARGS__
foo(
  create_work([=]{}); 
  create_work([=]{}); 
)
  \end{CppCode}
  Note that this is not a problem when using nested |create_work| calls:
  \begin{CppCode}
// $\yes$ not a problem
create_work([=]{ create_work([=]{}); }); // works fine
  \end{CppCode}
  Other than the obvious solution of putting the |create_work| invocations on
  multiple lines, this issue can be worked around by putting any of the later
  |create_work| calls within their own scopes:
  \begin{CppCode}
// $\yes$ works fine
create_work([=]{}); { create_work([=]{}); }
// $\yes$ also fine
foo(
  create_work([=]{}); 
  { create_work([=]{}); }
  { create_work([=]{}); }
)
  \end{CppCode}
\end{itemize}

