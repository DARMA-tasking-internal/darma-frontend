\chapter{DARMA Front End API}
\label{chap:front_end}
This chapter describes the DARMA \gls{front end} \gls{API}. 
\todo[inline]{summarize chapter breakdown into sections.}

\section{Keyword arguments}
\label{sec:keyword}

Similar to higher-level languages like Python, the DARMA C++ interface allows the user
to specify arguments to many of the API functions and constructs using either positional
or keyword arguments.  In addition, many optional arguments may {\em only} be specified using
keyword arguments.  The syntax for specifying a keyword argument is identical to that
of Python: \inlinecode{keyword=value}.  For instance, if there is a function \inlinecode{some_function} in the
DARMA API that accepts positional or keyword arguments \inlinecode{arg_a}, \inlinecode{count}, and \inlinecode{flag}, that 
function can be invoked equivalently in any of the following ways:
\begin{lstlisting}
/* some_function signature:
 *  void some_function(std::string arg_a, int count, bool flag);
 */
// All of the following are equivalent:
some_function("hello", 42, true);
some_function(arg_a="hello", count=42, flag=true);
some_function(count=42, flag=true, arg_a="hello");
some_function("hello", flag=true, count=42);
\end{lstlisting}
Note that positional arguments may {\em not} be specified after the first keyword argument,
and an argument cannot be specified more than once, even as a positional and keyword
argument.  Both of these lead to compile-time errors. Omitting a required argument is 
also a compile-time error, as is giving an argument of the incorrect type: 
\begin{lstlisting}
// Error: arg_a specified more than once
some_function("hello", 42, true, arg_a="whoops!");

// Error: missing required argument \inlinecode{flag}
some_function("hello", count=42);

// Error: cannot convert \inlinecode{bool} to \inlinecode{std::string}
some_function(arg_a=false, flag=true, count=42);
some_function(false, 42, true);

// Error: positional argument given after first keyword argument
some_function(arg_a="hello", 42, flag=true);
\end{lstlisting}
The illusion of Python-like keyword arguments is accomplished using \inlinecode{constexpr} instances
of a class with the assignment operator overloaded.  The arguments are passed to the 
callable using perfect forwarding, and thus the overhead from the keyword argument 
trick is entirely at compile-time.  These instances are defined in very descriptive
namespaces, and frequently used keywords are aliased into more general namespaces.  For
instance, the keywords for \inlinecode{some_function}, above, would probably be defined in the 
namespace \inlinecode{darma::keyword_arguments_for_some_function}.  If \inlinecode{some_function} was a 
widely used construct, its more important keywords would also be defined in the namespace
\inlinecode{darma::keyword_arguments}.  If \inlinecode{some_function} belonged to a broader category of 
constructs, certain of its keywords may also be aliased into a categorical namespace
as well.  For instance, if \inlinecode{some_function} implemented some memory management functionality,
its keywords may be aliased into \inlinecode{darma::keyword_arguments_for_memory_management} or 
something.  All of this is done so that the user can minimize verbosity without introducing
naming conflicts.  In certain contexts, it may be expedient for the user to simply
put \inlinecode{using darma::keyword_arguments} at the beginning of the calling context.  In other,
more complicated contexts, importing all DARMA keywords into the local context may
lead to naming conflicts with local variables.  You don't have to guess at which namespaces
a keyword is provided in or aliased into; every time a keyword argument or a callable
accepting that argument is introduced in the documentation, the namespace to which 
it belongs and all namespaces it is aliased into are given.



\section{SPMD support}
\label{sec:spmd}
SPMD being the dominant model of parallelism in DARMA, the spin-up of the runtime in each SPMD unit is 
kept analogous to MPI. This should make it a little easier for existing MPI based application codes to transition 
to DARMA. The initialization and termination of the runtime in each unit is via the calls \inlinecode{darma_init}
and \inlinecode{darma_finalize}. The total number of SPMD units are queried with the call \inlinecode{darma_spmd_size},
and the rank is queried with \inlinecode{darma_spmd_rank}. A typical user written main program will look as follows:
\begin{figure}
\definecolor{grayish}{gray}{0.95}
\begin{lstlisting}[basicstyle=\footnotesize,emph={entry,serial,when,overlap,forall},emphstyle=\textbf,backgroundcolor=\color{grayish},framexleftmargin=1em,numbers=left,numberstyle=\tiny,numbersep=5pt,escapeinside={(*@}{@*)}]
int main(int argc, char**argv){

	darma_init(argc, argv);

    size_t n_ranks = darma_spmd_size();
    size_t me = darma_spmd_rank();

    //lots of code

    darma_finalize();
}
\end{lstlisting}
\end{figure}

The rank is a very useful concept to orchestrate dependencies in a SPMD model since data pertaining to a rank can be associated
with a key that encodes the rank explicitly. Similarly, data that needs to be communicated to other ranks can be associated with
keys that encode the rank of the intended recepient. The example below illustrates this concept, where the rank is integral to
the key associated with data pertaining to that rank (the topic of access handles will be discussed shortly):
\begin{lstlisting}
size_t me = darma_spmd_rank();
auto float_handle = initial_access<float>("floatKey", me);
\end{lstlisting}  

<<<<<<< HEAD
=======
\inlinecode{dharma_spmd_rank()}

\inlinecode{dharma_spmd_size()}
>>>>>>> e74bf0b13bc345a543ab4179c3a78a9cc1c44ffb



\section{Deferred Tasks}
\label{sec:deferred}

\inlinecode{create_work}
variants, restrictions, usage of \inlinecode{waits}


\section{Access Handles}
\label{sec:handles}

\inlinecode{initial_access<T>(...)}

\inlinecode{read_access<T>(...)}

\inlinecode{read_write<T>(...)}


\inlinecode{publish}
\todo[inline]{should publish be called inside or outside create work, or does it not matter}

\inlinecode{n_readers=...}

\inlinecode{subscribe}


\todo[inline]{what else here?}
