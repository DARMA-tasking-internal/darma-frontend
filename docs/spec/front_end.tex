\chapter{DARMA Front End API}
\label{chap:front_end}
This chapter describes the DARMA \gls{front end} \gls{API}. 
\todo[inline]{summarize chapter breakdown into sections.}

\section{Keyword arguments}
\label{sec:keyword}

Similar to higher-level languages like Python, the DARMA C++ interface allows the user
to specify arguments to many of the API functions and constructs using either positional
or keyword arguments.  In addition, many optional arguments may {\em only} be specified using
keyword arguments.  The syntax for specifying a keyword argument is identical to that
of Python: \inlinecode{keyword=value}.  For instance, if there is a function \inlinecode{some_function} in the
DARMA API that accepts positional or keyword arguments \inlinecode{arg_a}, \inlinecode{count}, and \inlinecode{flag}, that 
function can be invoked equivalently in any of the following ways:
\begin{lstlisting}
/* some_function signature:
 *  void some_function(std::string arg_a, int count, bool flag);
 */
// All of the following are equivalent:
some_function("hello", 42, true);
some_function(arg_a="hello", count=42, flag=true);
some_function(count=42, flag=true, arg_a="hello");
some_function("hello", flag=true, count=42);
\end{lstlisting}
Note that positional arguments may {\em not} be specified after the first keyword argument,
and an argument cannot be specified more than once, even as a positional and keyword
argument.  Both of these lead to compile-time errors. Omitting a required argument is 
also a compile-time error, as is giving an argument of the incorrect type: 
\begin{lstlisting}
// Error: arg_a specified more than once
some_function("hello", 42, true, arg_a="whoops!");

// Error: missing required argument \inlinecode{flag}
some_function("hello", count=42);

// Error: cannot convert \inlinecode{bool} to \inlinecode{std::string}
some_function(arg_a=false, flag=true, count=42);
some_function(false, 42, true);

// Error: positional argument given after first keyword argument
some_function(arg_a="hello", 42, flag=true);
\end{lstlisting}
The illusion of Python-like keyword arguments is accomplished using \inlinecode{constexpr} instances
of a class with the assignment operator overloaded.  The arguments are passed to the 
callable using perfect forwarding, and thus the overhead from the keyword argument 
trick is entirely at compile-time.  These instances are defined in very descriptive
namespaces, and frequently used keywords are aliased into more general namespaces.  For
instance, the keywords for \inlinecode{some_function}, above, would probably be defined in the 
namespace \inlinecode{darma::keyword_arguments_for_some_function}.  If \inlinecode{some_function} was a 
widely used construct, its more important keywords would also be defined in the namespace
\inlinecode{darma::keyword_arguments}.  If \inlinecode{some_function} belonged to a broader category of 
constructs, certain of its keywords may also be aliased into a categorical namespace
as well.  For instance, if \inlinecode{some_function} implemented some memory management functionality,
its keywords may be aliased into \inlinecode{darma::keyword_arguments_for_memory_management} or 
something.  All of this is done so that the user can minimize verbosity without introducing
naming conflicts.  In certain contexts, it may be expedient for the user to simply
put \inlinecode{using darma::keyword_arguments} at the beginning of the calling context.  In other,
more complicated contexts, importing all DARMA keywords into the local context may
lead to naming conflicts with local variables.  You don't have to guess at which namespaces
a keyword is provided in or aliased into; every time a keyword argument or a callable
accepting that argument is introduced in the documentation, the namespace to which 
it belongs and all namespaces it is aliased into are given.



\section{SPMD support}
\label{sec:spmd}
SPMD being the dominant model of parallelism in DARMA, the spin-up of the runtime in each SPMD unit is 
kept analogous to MPI. This should make it a little easier for existing MPI based application codes to transition 
to DARMA. The initialization and termination of the runtime in each unit is via the calls \inlinecode{darma_init}
and \inlinecode{darma_finalize}. The total number of SPMD units are queried with the call \inlinecode{darma_spmd_size},
and the rank is queried with \inlinecode{darma_spmd_rank}. A typical user written main program will look as follows:
\begin{figure}[h!]
\definecolor{grayish}{gray}{0.95}
\begin{lstlisting}[emph={},emphstyle=\textbf,backgroundcolor=\color{grayish},framexleftmargin=1em,numbers=left,numberstyle=\tiny,numbersep=5pt,escapeinside={(*@}{@*)}]
int main(int argc, char**argv){

	darma_init(argc, argv);
	size_t n_ranks = darma_spmd_size();
	size_t me = darma_spmd_rank();

	//lots of code

	darma_finalize();
}
\end{lstlisting}
\end{figure}

The rank is a very useful concept to orchestrate dependencies in a SPMD model since data pertaining to a rank can be associated
with a key that encodes the rank explicitly. Similarly, data that needs to be communicated to other ranks can be associated with
keys that encode the rank of the intended recepient. The example below illustrates this concept, where the rank is integral to
the key associated with data pertaining to that rank (the topic of access handles will be discussed shortly):
\begin{lstlisting}
size_t me = darma_spmd_rank();
auto float_handle = initial_access<float>("floatKey", me);
\end{lstlisting}  


\section{Deferred Tasks}
\label{sec:deferred}

\inlinecode{create_work}
variants, restrictions, usage of \inlinecode{waits}


\section{Access Handles}
\label{sec:handles}

Transactions with the key-value store are conducted using data handles that are of different access types which differentiate the 
various transactions. At the most basic level user code can declare a handle to data that does not yet exist in the system
but needs to be created, handle to data that already exists and needs to be read or handle to data that it wants to overwrite. 

The first of these types is denoted as \inlinecode{initial_access} in DARMA, which informs the runtime that the data with the 
specified key does not yet exist, and the user intends to create this data and publish it shortly. Hence, an \inlinecode{initial_access}
data handle is usually followed by a memory allocation, a value assignment and finally a publish operation, as illustrated below: 
\begin{lstlisting}
auto float_handle = initial_access<float>("floatKey");
float_handle.set_value(3.14);
float_handle.publish(n_readers=1);
\end{lstlisting}
The \inlinecode{n_readers} specification in the publish call informs the runtime that this data (associated with the key "floatKey") will
only ever be read once, and hence can be safely garbage collected soon after.
\todo[inline]{Need to explain what happens if initial access is not followed by a publish. Illegal, or unsafe programming.}


The second type of transaction, requesting read-only access to a piece of data, is via the access handle \inlinecode{read_access}. The runtime
guarantees that any task that uses this handle will be launched once the data is available anywhere in the system, even on a remote node.
It will be illegal to overwrite and publish the data that is accessed via this handle. Conversely, it is illegal to request a \inlinecode{read_access}
handle to data that will never be created or published by any other task.
\begin{lstlisting}
auto float_handle = read_access<float>("another_floatKey");
float val = float_handle.get_value();
std::cout << "Value read with key another_floatKey is " << val;
\end{lstlisting}

And the last type, which informs the runtime that the data with the specified key will be read and overwritten, is with the \inlinecode{read_write_access}
handle, illustrated below
\begin{lstlisting}
auto float_handle = read_write<float>("yet_another_floatKey");
std::cout << "Value read with key yet_another_floatKey is " << float_handle.get_value();
float_handle.set_value(3.14*2.0);
float_handle.publish();
\end{lstlisting}


\todo[inline]{should publish be called inside or outside create work, or does it not matter}


\inlinecode{subscribe}

\todo[inline]{what else here?}
